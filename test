--// Severe Library //--
-- Optimized library for Severe API
-- Main focus: Performance, Stability, Reusability

-- Cache common functions for better performance
local cache = {
    loadstring_cache = {},
    httpget_cache = {},
}

-- Screen dimensions
local Screen = {
    x = getscreendimensions().x,
    y = getscreendimensions().y
}

-- Initialize Library
local slib = {
    -- Colors presets
    Colors = {
        White = {255, 255, 255},
        Black = {0, 0, 0},
        Red = {255, 0, 0},
        Green = {0, 255, 0},
        Blue = {0, 0, 255},
        Yellow = {255, 255, 0},
        Cyan = {0, 255, 255},
        Magenta = {255, 0, 255},
        Orange = {255, 165, 0},
        Purple = {128, 0, 128},
        Pink = {255, 192, 203},
        Gray = {128, 128, 128},
    },
    
    -- Rainbow color generator
    RainbowHue = 0,
    CurrentRainbowColor = {255, 255, 255},
    
    -- Drawing objects collection for easy cleanup
    DrawingObjects = {},
    
    -- Debug settings
    Debug = {
        Enabled = false,
        LogHistory = {},
        MaxLogs = 50
    }
}

--// Core Functions //--

-- Get coordinates based on percentage of screen
function slib.GetCoords(percentage)
    assert(type(percentage) == "table" and #percentage == 2, "GetCoords: First argument needs to be a table with 2 values (x%, y%)!")
    
    return {
        Screen.x * (percentage[1] / 100),
        Screen.y * (percentage[2] / 100)
    }
end

-- Get distance between two positions
function slib.GetDistance(pos1, pos2)
    -- Handle different input types
    local v1, v2 = {}, {}
    
    -- Process pos1
    if type(pos1) == "table" then
        if pos1.x and pos1.y and pos1.z then
            v1 = pos1
        else
            assert(#pos1 == 3, "GetDistance: First argument needs to be a table with 3 values!")
            v1 = {x = pos1[1], y = pos1[2], z = pos1[3]}
        end
    elseif type(pos1) == "number" then
        v1 = getposition(pos1)
    else
        error("GetDistance: First argument needs to be a table with position values or an instance!")
        return
    end
    
    -- Process pos2
    if type(pos2) == "table" then
        if pos2.x and pos2.y and pos2.z then
            v2 = pos2
        else
            assert(#pos2 == 3, "GetDistance: Second argument needs to be a table with 3 values!")
            v2 = {x = pos2[1], y = pos2[2], z = pos2[3]}
        end
    elseif type(pos2) == "number" then
        v2 = getposition(pos2)
    else
        error("GetDistance: Second argument needs to be a table with position values or an instance!")
        return
    end
    
    -- Calculate distance
    local dx = v1.x - v2.x
    local dy = v1.y - v2.y
    local dz = v1.z - v2.z
    
    return math.sqrt(dx*dx + dy*dy + dz*dz)
end

-- Update rainbow color
function slib.UpdateRainbow(speed)
    speed = speed or 3
    
    if slib.RainbowHue > 1530 then
        slib.RainbowHue = 0
    else
        slib.RainbowHue = slib.RainbowHue + speed
    end
    
    if slib.RainbowHue <= 255 then
        slib.CurrentRainbowColor = {255, slib.RainbowHue, 0}
    elseif slib.RainbowHue <= 510 then
        slib.CurrentRainbowColor = {510 - slib.RainbowHue, 255, 0}
    elseif slib.RainbowHue <= 765 then
        slib.CurrentRainbowColor = {0, 255, slib.RainbowHue - 510}
    elseif slib.RainbowHue <= 1020 then
        slib.CurrentRainbowColor = {0, 1020 - slib.RainbowHue, 255}
    elseif slib.RainbowHue <= 1275 then
        slib.CurrentRainbowColor = {slib.RainbowHue - 1020, 0, 255}
    elseif slib.RainbowHue <= 1530 then
        slib.CurrentRainbowColor = {255, 0, 1530 - slib.RainbowHue}
    end
    
    return slib.CurrentRainbowColor
end

-- Check if mouse is in specified area
function slib.IsMouseInArea(area)
    assert(type(area) == "table" and #area == 4, "IsMouseInArea: First argument needs to be a table with 4 values!")
    
    local mouse = getmouseposition()
    
    if mouse.x > area[1] and mouse.y > area[2] and 
       mouse.x < area[3] and mouse.y < area[4] then
        return true
    else
        return false
    end
end

-- Optimized HTTP Get with caching
function slib.HttpGet(url)
    assert(type(url) == "string", "HttpGet: First argument needs to be a string!")
    
    if cache.httpget_cache[url] == nil then
        cache.httpget_cache[url] = httpget(url)
    end
    
    return cache.httpget_cache[url]
end

-- Optimized loadstring with caching
function slib.Loadstring(str)
    assert(type(str) == "string", "Loadstring: First argument needs to be a string!")
    
    if cache.loadstring_cache[str] == nil then
        cache.loadstring_cache[str] = loadstring(str)
    end
    
    return cache.loadstring_cache[str]
end

--// Drawing Functions //--

-- Create a new drawing object and add to collection
function slib.NewDrawing(type, properties)
    assert(type(type) == "string", "NewDrawing: First argument needs to be a string!")
    
    local object = Drawing.new(type)
    
    if properties then
        for property, value in pairs(properties) do
            object[property] = value
        end
    end
    
    table.insert(slib.DrawingObjects, object)
    return object
end

-- Clear all drawing objects
function slib.ClearDrawings()
    for _, object in pairs(slib.DrawingObjects) do
        object:Remove()
    end
    
    slib.DrawingObjects = {}
end

-- Create a healthbar
function slib.HealthBar(params)
    assert(type(params) == "table", "HealthBar: First argument needs to be a table!")
    assert(type(params.Position) == "table", "HealthBar: Position field must be a table!")
    assert(type(params.HP) == "number", "HealthBar: HP field must be a number!")
    
    local position = params.Position
    local hp = params.HP
    local maxHp = params.MaxHP or 100
    local size = params.Size or {120, 5}
    local offset = params.Offset or {0, 0}
    local outlined = params.Outlined ~= false -- Default to true
    
    -- Convert 3D position to 2D screen position
    local screenPos
    if #position == 3 then
        local wts = worldtoscreenpoint({position[1], position[2], position[3]})
        if not wts[2] then return end -- Position is not on screen
        screenPos = {wts[1].x, wts[1].y}
    else
        screenPos = position
    end
    
    -- Health percentage
    local healthPercentage = math.max(0, math.min(1, hp / maxHp))
    local barWidth = size[1] * healthPercentage
    
    -- Position calculation
    local x, y = screenPos[1] + offset[1], screenPos[2] + offset[2]
    
    -- Calculate health color (green to red gradient)
    local healthColor = {
        255 - (255 * healthPercentage),
        255 * healthPercentage,
        0
    }
    
    -- Create the health bar background
    if outlined then
        local outline = slib.NewDrawing("Square", {
            Position = {x - size[1]/2 - 1, y - 1},
            Size = {size[1] + 2, size[2] + 2},
            Color = slib.Colors.Black,
            Filled = true,
            Visible = true
        })
    end
    
    -- Create background
    local background = slib.NewDrawing("Square", {
        Position = {x - size[1]/2, y},
        Size = {size[1], size[2]},
        Color = {40, 40, 40},
        Filled = true,
        Visible = true
    })
    
    -- Create foreground health indicator
    local foreground = slib.NewDrawing("Square", {
        Position = {x - size[1]/2, y},
        Size = {barWidth, size[2]},
        Color = healthColor,
        Filled = true,
        Visible = true
    })
    
    return {background, foreground}
end

-- Create ESP box for an entity
function slib.BoxESP(params)
    assert(type(params) == "table", "BoxESP: First argument needs to be a table!")
    assert(type(params.Target) == "number", "BoxESP: Target field must be an instance!")
    
    local target = params.Target
    local color = params.Color or slib.Colors.White
    local boxType = params.BoxType or "2D" -- "2D", "3D", or "Corners"
    
    -- Find HumanoidRootPart
    local torso = findfirstchild(target, "HumanoidRootPart")
    if not torso then return end
    
    local pos = getposition(torso)
    
    -- Get character dimensions
    local headPosY = pos.y + 2.5
    local legPosY = pos.y - 3.5
    
    -- Convert to screen positions
    local topPos = worldtoscreenpoint({pos.x, headPosY, pos.z})
    local bottomPos = worldtoscreenpoint({pos.x, legPosY, pos.z})
    
    -- Check if on screen
    if not topPos[2] or not bottomPos[2] then return end
    
    local top = topPos[1]
    local bottom = bottomPos[1]
    
    -- Calculate box dimensions
    local height = top.y - bottom.y
    local width = height / 2.4
    
    -- Draw based on box type
    if boxType == "2D" then
        -- Create full box
        local box = slib.NewDrawing("Square", {
            Position = {bottom.x - width/2, top.y},
            Size = {width, height},
            Color = color,
            Thickness = 1,
            Filled = false,
            Visible = true
        })
        return box
        
    elseif boxType == "Corners" then
        -- Create corner lines
        local lines = {}
        local cornerSize = height / 4
        
        -- Top left
        table.insert(lines, slib.NewDrawing("Line", {
            From = {bottom.x - width/2, top.y},
            To = {bottom.x - width/2 + cornerSize, top.y},
            Color = color,
            Thickness = 1,
            Visible = true
        }))
        
        table.insert(lines, slib.NewDrawing("Line", {
            From = {bottom.x - width/2, top.y},
            To = {bottom.x - width/2, top.y + cornerSize},
            Color = color,
            Thickness = 1,
            Visible = true
        }))
        
        -- Top right
        table.insert(lines, slib.NewDrawing("Line", {
            From = {bottom.x + width/2, top.y},
            To = {bottom.x + width/2 - cornerSize, top.y},
            Color = color,
            Thickness = 1,
            Visible = true
        }))
        
        table.insert(lines, slib.NewDrawing("Line", {
            From = {bottom.x + width/2, top.y},
            To = {bottom.x + width/2, top.y + cornerSize},
            Color = color,
            Thickness = 1,
            Visible = true
        }))
        
        -- Bottom left
        table.insert(lines, slib.NewDrawing("Line", {
            From = {bottom.x - width/2, bottom.y},
            To = {bottom.x - width/2 + cornerSize, bottom.y},
            Color = color,
            Thickness = 1,
            Visible = true
        }))
        
        table.insert(lines, slib.NewDrawing("Line", {
            From = {bottom.x - width/2, bottom.y},
            To = {bottom.x - width/2, bottom.y - cornerSize},
            Color = color,
            Thickness = 1,
            Visible = true
        }))
        
        -- Bottom right
        table.insert(lines, slib.NewDrawing("Line", {
            From = {bottom.x + width/2, bottom.y},
            To = {bottom.x + width/2 - cornerSize, bottom.y},
            Color = color,
            Thickness = 1,
            Visible = true
        }))
        
        table.insert(lines, slib.NewDrawing("Line", {
            From = {bottom.x + width/2, bottom.y},
            To = {bottom.x + width/2, bottom.y - cornerSize},
            Color = color,
            Thickness = 1,
            Visible = true
        }))
        
        return lines
    end
end

-- Create tracer to target
function slib.Tracer(params)
    assert(type(params) == "table", "Tracer: First argument needs to be a table!")
    assert(type(params.Target) == "number" or type(params.Position) == "table", "Tracer: Target or Position must be provided!")
    
    local position
    if params.Target then
        -- Get position from target
        local target = params.Target
        local part = params.Part and findfirstchild(target, params.Part) or findfirstchild(target, "HumanoidRootPart")
        if not part then return end
        
        position = getposition(part)
    else
        -- Use provided position
        position = params.Position
    end
    
    -- Convert 3D position to 2D screen position
    local screenPos
    if position.x and position.y and position.z then
        local wts = worldtoscreenpoint({position.x, position.y, position.z})
        if not wts[2] then return end -- Not on screen
        screenPos = {wts[1].x, wts[1].y}
    else
        screenPos = position
    end
    
    -- Get tracer origin point
    local origin = params.Origin or "Bottom" -- "Bottom", "Top", "Center", "Mouse"
    local originPos
    
    if origin == "Bottom" then
        originPos = {Screen.x / 2, Screen.y}
    elseif origin == "Top" then
        originPos = {Screen.x / 2, 0}
    elseif origin == "Center" then
        originPos = {Screen.x / 2, Screen.y / 2}
    elseif origin == "Mouse" then
        local mousePos = getmouseposition()
        originPos = {mousePos.x, mousePos.y}
    else
        originPos = {Screen.x / 2, Screen.y}
    end
    
    -- Create tracer
    local tracer = slib.NewDrawing("Line", {
        From = {originPos[1], originPos[2]},
        To = {screenPos[1], screenPos[2]},
        Color = params.Color or slib.Colors.White,
        Thickness = params.Thickness or 1,
        Visible = true
    })
    
    return tracer
end

--// Player Functions //--

-- Get all players
function slib.GetPlayers()
    local Game = Game
    local Players = findfirstchildofclass(Game, "Players")
    return getchildren(Players)
end

-- Get local player info
function slib.GetLocalPlayerData()
    local player = getlocalplayer()
    local character = getcharacter(player)
    
    if not character then
        return {
            Player = player,
            Username = getname(player),
            DisplayName = getdisplayname(player),
            UserId = getuserid(player)
        }
    end
    
    local humanoid = findfirstchild(character, "Humanoid")
    local rootPart = findfirstchild(character, "HumanoidRootPart")
    local head = findfirstchild(character, "Head")
    
    return {
        Player = player,
        Character = character,
        Username = getname(player),
        DisplayName = getdisplayname(player),
        UserId = getuserid(player),
        Humanoid = humanoid,
        RootPart = rootPart,
        Head = head,
        Health = humanoid and gethealth(humanoid) or 0,
        MaxHealth = humanoid and getmaxhealth(humanoid) or 0,
        Position = rootPart and getposition(rootPart) or {x=0, y=0, z=0}
    }
end

-- Create model data for Severe
function slib.CreateModelData(model)
    assert(type(model) == "number", "CreateModelData: First argument needs to be an instance!")
    
    local humanoid = findfirstchild(model, "Humanoid")
    local head = findfirstchild(model, "Head")
    local torso = findfirstchild(model, "Torso") or findfirstchild(model, "UpperTorso")
    local rootPart = findfirstchild(model, "HumanoidRootPart")
    local leftArm = findfirstchild(model, "Left Arm") or findfirstchild(model, "LeftUpperArm")
    local rightArm = findfirstchild(model, "Right Arm") or findfirstchild(model, "RightUpperArm")
    local leftLeg = findfirstchild(model, "Left Leg") or findfirstchild(model, "LeftUpperLeg")
    local rightLeg = findfirstchild(model, "Right Leg") or findfirstchild(model, "RightUpperLeg")
    
    -- Determine rig type
    local rigType = 0 -- R6 = 0, R15 = 1
    if findfirstchild(model, "UpperTorso") then
        rigType = 1
    end
    
    local data = {
        Username = getname(model),
        Displayname = getname(model),
        Userid = 0,
        Character = model,
        PrimaryPart = rootPart,
        Humanoid = humanoid,
        Head = head,
        LeftLeg = leftLeg,
        LeftArm = leftArm,
        RightArm = rightArm,
        RightLeg = rightLeg,
        Torso = torso,
        BodyHeightScale = 1,
        RigType = rigType,
        Whitelisted = false,
        Archenemies = false,
        Aimbot_Part = head,
        Aimbot_TP_Part = head,
        Triggerbot_Part = head,
        Health = humanoid and gethealth(humanoid) or 100,
        MaxHealth = humanoid and getmaxhealth(humanoid) or 100,
    }
    
    return data
end

--// Debug Functions //--

-- Log message to debug console
function slib.Log(message, color)
    assert(type(message) == "string", "Log: First argument needs to be a string!")
    
    if not slib.Debug.Enabled then
        return
    end
    
    -- Add to log history
    table.insert(slib.Debug.LogHistory, {
        Message = message,
        Color = color or slib.Colors.White,
        Time = os.date("%H:%M:%S")
    })
    
    -- Trim log history if too long
    if #slib.Debug.LogHistory > slib.Debug.MaxLogs then
        table.remove(slib.Debug.LogHistory, 1)
    end
    
    -- Also print to console
    print(message)
end

-- Draw debug console on screen
function slib.DrawDebugConsole(x, y, width, height)
    if not slib.Debug.Enabled then
        return
    end
    
    x = x or 10
    y = y or 10
    width = width or 300
    height = height or 200
    
    -- Create background
    local background = slib.NewDrawing("Square", {
        Position = {x, y},
        Size = {width, height},
        Color = {30, 30, 30},
        Transparency = 0.8,
        Filled = true,
        Visible = true
    })
    
    -- Create header
    local header = slib.NewDrawing("Text", {
        Text = "Severe Library Debug Console",
        Position = {x + 5, y + 5},
        Size = 18,
        Color = slib.Colors.White,
        Visible = true
    })
    
    -- Create log entries
    local logY = y + 30
    for i = #slib.Debug.LogHistory, math.max(1, #slib.Debug.LogHistory - 10), -1 do
        local log = slib.Debug.LogHistory[i]
        if log then
            local entry = slib.NewDrawing("Text", {
                Text = log.Time .. ": " .. log.Message,
                Position = {x + 10, logY},
                Size = 15,
                Color = log.Color,
                Visible = true
            })
            logY = logY + 18
        end
    end
end

--// Sleep function (non-blocking) //--
slib.SleepTasks = {}
function slib.Sleep(duration, callback, identifier)
    assert(type(duration) == "number", "Sleep: First argument needs to be a number!")
    assert(type(callback) == "function", "Sleep: Second argument needs to be a function!")
    
    local taskId = identifier or tostring(callback) .. tick()
    local endTime = tick() + duration
    
    slib.SleepTasks[taskId] = {
        EndTime = endTime,
        Callback = callback
    }
    
    return taskId
end

-- Process sleep tasks
function slib.ProcessSleepTasks()
    local currentTime = tick()
    local tasksToRemove = {}
    
    for id, task in pairs(slib.SleepTasks) do
        if currentTime >= task.EndTime then
            task.Callback()
            table.insert(tasksToRemove, id)
        end
    end
    
    for _, id in ipairs(tasksToRemove) do
        slib.SleepTasks[id] = nil
    end
end

-- Main update function to be called each frame
function slib.Update()
    -- Update screen dimensions
    Screen.x = getscreendimensions().x
    Screen.y = getscreendimensions().y
    
    -- Process sleep tasks
    slib.ProcessSleepTasks()
    
    -- Update rainbow color
    slib.UpdateRainbow()
end

-- Return the library
return slib 
