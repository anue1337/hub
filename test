--[[
    Severe Library - An optimized utility library for Severe
    
    Features:
    - Optimized ESP functionality
    - Game object utilities
    - Mouse/input helpers
    - Distance calculations
    - Drawing utilities
]]

-- Initialize library
if not _G.svlib then
    _G.svlib = {
        -- Configuration
        Config = {
            ESP = {
                Enabled = false,
                BoxColor = {255, 255, 255},
                HealthbarEnabled = true,
                NametagEnabled = true,
                DistanceEnabled = true,
                TracerEnabled = false,
                TracerOrigin = "Bottom", -- "Bottom", "Top", "Mouse"
                BoxType = "Corners", -- "Corners", "2D", "3D"
            },
            Aimbot = {
                Enabled = false,
                Smoothness = 0.5,
                FOV = 100,
                TargetPart = "Head",
            },
            Colors = {
                Primary = {255, 255, 255},
                Secondary = {25, 25, 25},
                Accent = {255, 0, 0},
                Background = {15, 15, 15},
                Warning = {255, 200, 0},
                Error = {255, 50, 50},
                Success = {0, 255, 50},
            },
            Performance = {
                MaxESPDistance = 1000,
                MaxDrawObjects = 200,
                UpdateRate = 0.05, -- 20 FPS default (anti-crash setting)
                CleanRate = 1.0, -- 1 segundo entre limpezas
                EnableAntiCrash = true, -- Sempre ativado por padrão
                ObjectLimit = true, -- Limitar objetos por personagem
                MaxObjectsPerCharacter = 20, -- Limite de objetos por personagem
                ReuseObjects = true, -- Reutilizar objetos existentes em vez de criar novos
            },
        },
        
        -- Cache for optimization
        Cache = {
            PlayerData = {},
            DrawingObjects = {},
            CharacterESP = {}, -- Cache for character ESP objects
            DrawingPool = {}, -- Pool de objetos para reutilização
            LastUpdate = 0,
            UpdateInProgress = false,
            CleanupInProgress = false,
            ThreadActive = false,
            LocalPlayer = nil,
            Camera = nil,
            ScreenSize = {x = 0, y = 0},
            LastCleanup = 0,
            FrameCount = 0,
        },
        
        -- Stats for debugging
        Stats = {
            FrameTime = 0,
            ObjectsDrawn = 0,
            LastUpdate = 0,
            Crashes = 0,
            MaxObjects = 0,
            PoolSize = 0,
        },
    }
end

-- Reference to the library
local svlib = _G.svlib

-- Shorthand to Game
local Game = Game

----------------------------------
-- Utility Functions
----------------------------------

-- Get screen dimensions
function svlib.UpdateScreenSize()
    local dims = getscreendimensions()
    svlib.Cache.ScreenSize = {x = dims.x, y = dims.y}
    return svlib.Cache.ScreenSize
end

-- Check if mouse is in an area
function svlib.IsMouseInArea(x1, y1, x2, y2)
    local mouse = getmouseposition()
    return (mouse.x >= x1 and mouse.x <= x2 and mouse.y >= y1 and mouse.y <= y2)
end

-- Get distance between two positions
function svlib.GetDistance(pos1, pos2)
    local x = pos1.x - pos2.x
    local y = pos1.y - pos2.y
    local z = pos1.z - pos2.z
    return math.sqrt(x*x + y*y + z*z)
end

-- Get distance from position to player
function svlib.GetDistanceFromPlayer(pos)
    local character = getcharacter(getlocalplayer())
    if not character then return 0 end
    
    local rootPart = findfirstchild(character, "HumanoidRootPart")
    if not rootPart then return 0 end
    
    local playerPos = getposition(rootPart)
    return svlib.GetDistance(playerPos, pos)
end

-- Get game service
function svlib.GetService(serviceName)
    return findservice(Game, serviceName)
end

-- Navigate Game path easily
function svlib.Game(...)
    local current = Game
    local args = {...}
    
    for _, path in ipairs(args) do
        current = findfirstchild(current, path)
        if not current then return nil end
    end
    
    return current
end

-- Get descendants
function svlib.GetDescendants(instance)
    local result = {}
    local function addDescendants(parent)
        local children = getchildren(parent)
        for _, child in ipairs(children) do
            table.insert(result, child)
            addDescendants(child)
        end
    end
    
    addDescendants(instance)
    return result
end

-- Check if a part is valid and not corrupted
function svlib.IsValidPart(part)
    if not part then return false end
    
    local success, className = pcall(function() 
        return getclassname(part) 
    end)
    
    if not success or not className then return false end
    
    local validClasses = {
        ["Part"] = true,
        ["MeshPart"] = true,
        ["TrussPart"] = true,
        ["WedgePart"] = true,
    }
    
    return validClasses[className] or false
end

-- Get descendants of class
function svlib.GetDescendantsOfClass(instance, className)
    local result = {}
    
    for _, descendant in ipairs(svlib.GetDescendants(instance)) do
        local success, classType = pcall(function() 
            return getclassname(descendant) 
        end)
        
        if success and classType == className then
            table.insert(result, descendant)
        end
    end
    
    return result
end

-- Find closest part in a model
function svlib.GetClosestPart(model)
    local parts = {}
    local validClasses = {
        ["Part"] = true,
        ["MeshPart"] = true,
        ["TrussPart"] = true,
        ["WedgePart"] = true,
    }
    
    local success, descendants = pcall(function()
        return svlib.GetDescendants(model)
    end)
    
    if not success or not descendants then
        return nil
    end
    
    for _, descendant in ipairs(descendants) do
        local className = getclassname(descendant)
        if validClasses[className] then
            table.insert(parts, descendant)
        end
    end
    
    local closestDistance = math.huge
    local closestPart = nil
    
    for _, part in ipairs(parts) do
        local posSuccess, pos = pcall(function() 
            return getposition(part) 
        end)
        
        if posSuccess and pos then
            local distance = svlib.GetDistanceFromPlayer(pos)
            if distance < closestDistance then
                closestDistance = distance
                closestPart = part
            end
        end
    end
    
    return closestPart
end

----------------------------------
-- Player Functions
----------------------------------

-- Get local player
function svlib.GetLocalPlayer()
    if not svlib.Cache.LocalPlayer then
        svlib.Cache.LocalPlayer = getlocalplayer()
    end
    return svlib.Cache.LocalPlayer
end

-- Get local character
function svlib.GetLocalCharacter()
    local player = svlib.GetLocalPlayer()
    return getcharacter(player)
end

-- Get player by name
function svlib.GetPlayer(name)
    local players = svlib.GetService("Players")
    local children = getchildren(players)
    
    for _, player in ipairs(children) do
        if getname(player) == name then
            return player
        end
    end
    
    return nil
end

-- Get all players
function svlib.GetPlayers()
    local players = svlib.GetService("Players")
    return getchildren(players)
end

-- Check if player is an enemy
function svlib.IsEnemy(player)
    local localPlayer = svlib.GetLocalPlayer()
    local localTeam = getteam(localPlayer)
    local playerTeam = getteam(player)
    
    if not localTeam or not playerTeam then return true end
    return localTeam ~= playerTeam
end

-- Get humanoid health
function svlib.GetHealth(humanoid)
    local success, health = pcall(function() return gethealth(humanoid) end)
    local successMax, maxHealth = pcall(function() return getmaxhealth(humanoid) end)
    
    if not success or not successMax then
        return { Health = 100, MaxHealth = 100 }
    end
    
    return {
        Health = health,
        MaxHealth = maxHealth
    }
end

----------------------------------
-- Drawing Functions
----------------------------------

-- Initialize a new cached drawing object
function svlib.NewDrawing(drawingType, properties)
    -- Check if we exceed max objects (anti-crash)
    if svlib.Config.Performance.EnableAntiCrash and #svlib.Cache.DrawingObjects >= svlib.Config.Performance.MaxDrawObjects then
        return nil
    end
    
    -- Create the drawing object
    local success, drawing = pcall(function()
        return Drawing.new(drawingType)
    end)
    
    if not success or not drawing then
        svlib.Stats.Crashes = svlib.Stats.Crashes + 1
        return nil
    end
    
    -- Set the properties
    for property, value in pairs(properties or {}) do
        pcall(function() drawing[property] = value end)
    end
    
    -- Add to cache for management
    table.insert(svlib.Cache.DrawingObjects, drawing)
    
    -- Update stats
    if #svlib.Cache.DrawingObjects > svlib.Stats.MaxObjects then
        svlib.Stats.MaxObjects = #svlib.Cache.DrawingObjects
    end
    
    -- Return the drawing object
    return drawing
end

-- Get object from pool or create new
function svlib.GetDrawingObject(drawingType, properties)
    -- Verificar limites de objetos
    if svlib.Config.Performance.EnableAntiCrash and #svlib.Cache.DrawingObjects >= svlib.Config.Performance.MaxDrawObjects then
        -- Tente limpar alguns objetos primeiro
        svlib.CleanupInvalidDrawings()
        
        -- Se ainda estiver acima do limite, não criar novo objeto
        if #svlib.Cache.DrawingObjects >= svlib.Config.Performance.MaxDrawObjects then
            return nil
        end
    end
    
    local drawing = nil
    
    -- Tentar reutilizar um objeto do pool
    if svlib.Config.Performance.ReuseObjects and #svlib.Cache.DrawingPool > 0 then
        for i, poolObj in ipairs(svlib.Cache.DrawingPool) do
            -- Verificar se o objeto é do tipo certo e válido
            local success, isValid = pcall(function() 
                return poolObj.Visible ~= nil
            end)
            
            if success and isValid then
                -- Encontramos um objeto válido no pool
                drawing = poolObj
                table.remove(svlib.Cache.DrawingPool, i)
                break
            end
        end
    end
    
    -- Se não encontrou no pool, criar novo
    if not drawing then
        local success, newDrawing = pcall(function()
            return Drawing.new(drawingType)
        end)
        
        if not success or not newDrawing then
            return nil
        end
        
        drawing = newDrawing
    end
    
    -- Aplicar propriedades
    for property, value in pairs(properties or {}) do
        pcall(function() drawing[property] = value end)
    end
    
    -- Adicionar à lista ativa
    table.insert(svlib.Cache.DrawingObjects, drawing)
    
    -- Update stats
    if #svlib.Cache.DrawingObjects > svlib.Stats.MaxObjects then
        svlib.Stats.MaxObjects = #svlib.Cache.DrawingObjects
    end
    
    return drawing
end

-- Clear all drawing objects
function svlib.ClearDrawings(immediate)
    if svlib.Cache.CleanupInProgress and not immediate then return end
    svlib.Cache.CleanupInProgress = true
    
    -- Se não for uma limpeza imediata, fazer gradualmente
    local objectsToRemove = {}
    
    for i, drawing in ipairs(svlib.Cache.DrawingObjects) do
        -- Se for limpeza imediata, remover tudo. Senão, limitar a 50 objetos por vez
        if immediate or i <= 50 then
            table.insert(objectsToRemove, {index = i, obj = drawing})
        end
    end
    
    -- Sort in reverse order to avoid index shifting when removing
    table.sort(objectsToRemove, function(a, b) return a.index > b.index end)
    
    for _, data in ipairs(objectsToRemove) do
        -- Em vez de destruir, mover para o pool para reutilização
        if svlib.Config.Performance.ReuseObjects and data.obj and data.obj.Visible ~= nil then
            -- Esconder o objeto e adicionar ao pool
            pcall(function() 
                data.obj.Visible = false
                table.insert(svlib.Cache.DrawingPool, data.obj)
            end)
        else
            -- Destruir se não estiver reutilizando ou o objeto for inválido
            pcall(function() 
                if data.obj and data.obj.Remove then 
                    data.obj:Remove() 
                end
            end)
        end
        
        -- Remover da lista ativa
        table.remove(svlib.Cache.DrawingObjects, data.index)
    end
    
    -- Se não for limpeza imediata e ainda houver objetos, programar outra limpeza
    if not immediate and #svlib.Cache.DrawingObjects > 0 then
        spawn(function()
            wait(0.1) -- Esperar um pouco antes da próxima rodada
            svlib.Cache.CleanupInProgress = false
            svlib.ClearDrawings(false)
        end)
    else
        svlib.Cache.CharacterESP = {}
        svlib.Cache.CleanupInProgress = false
    end
    
    -- Atualizar estatísticas do pool
    svlib.Stats.PoolSize = #svlib.Cache.DrawingPool
end

-- Remove a specific drawing object
function svlib.RemoveDrawing(drawing)
    for i, obj in ipairs(svlib.Cache.DrawingObjects) do
        if obj == drawing then
            pcall(function() obj:Remove() end)
            table.remove(svlib.Cache.DrawingObjects, i)
            break
        end
    end
end

-- Clear invalid drawing objects only (memory optimization)
function svlib.CleanupInvalidDrawings()
    if svlib.Cache.CleanupInProgress then return end
    svlib.Cache.CleanupInProgress = true
    
    local invalidObjects = {}
    
    for i, drawing in ipairs(svlib.Cache.DrawingObjects) do
        local isValid = pcall(function() return drawing.Visible ~= nil end)
        if not isValid then
            table.insert(invalidObjects, i)
        end
    end
    
    -- Sort in reverse order to avoid index shifting when removing
    table.sort(invalidObjects, function(a, b) return a > b end)
    
    for _, index in ipairs(invalidObjects) do
        pcall(function() 
            local obj = svlib.Cache.DrawingObjects[index]
            if obj and obj.Remove then obj:Remove() end
        end)
        table.remove(svlib.Cache.DrawingObjects, index)
    end
    
    -- Also cleanup character ESP cache for characters that no longer exist
    local charactersToRemove = {}
    for character, espData in pairs(svlib.Cache.CharacterESP) do
        if not espData or not character then
            table.insert(charactersToRemove, character)
        else
            local exists = pcall(function() 
                return isdescendantof(character, svlib.GetService("Workspace")) 
            end)
            
            if not exists then
                -- Remove all drawing objects for this character
                for _, obj in pairs(espData) do
                    if type(obj) == "table" then
                        for _, drawing in pairs(obj) do
                            pcall(function() 
                                if drawing and drawing.Remove then 
                                    drawing:Remove() 
                                end 
                            end)
                        end
                    elseif obj and obj.Remove then
                        pcall(function() obj:Remove() end)
                    end
                end
                
                table.insert(charactersToRemove, character)
            end
        end
    end
    
    -- Remove invalid characters from cache
    for _, character in ipairs(charactersToRemove) do
        svlib.Cache.CharacterESP[character] = nil
    end
    
    svlib.Cache.CleanupInProgress = false
end

-- Draw a 2D box
function svlib.Draw2DBox(position, size, color, thickness)
    local box = svlib.NewDrawing("Square", {
        Position = {position.x - size.x/2, position.y - size.y/2},
        Size = {size.x, size.y},
        Color = color or svlib.Config.Colors.Primary,
        Thickness = thickness or 1,
        Filled = false,
        Visible = true
    })
    return box
end

-- Draw a health bar
function svlib.DrawHealthBar(position, size, health, maxHealth)
    local background = svlib.NewDrawing("Square", {
        Position = {position.x, position.y},
        Size = {size.x, size.y},
        Color = {0, 0, 0},
        Filled = true,
        Visible = true
    })
    
    local healthRatio = math.min(1, health / maxHealth)
    local healthColor = {
        255 * (1 - healthRatio),
        255 * healthRatio,
        0
    }
    
    local fill = svlib.NewDrawing("Square", {
        Position = {position.x, position.y},
        Size = {size.x * healthRatio, size.y},
        Color = healthColor,
        Filled = true,
        Visible = true
    })
    
    return {
        Background = background,
        Fill = fill
    }
end

-- Draw text
function svlib.DrawText(position, text, size, color, center)
    local textObj = svlib.NewDrawing("Text", {
        Position = {position.x, position.y},
        Text = text,
        Size = size or 13,
        Color = color or svlib.Config.Colors.Primary,
        Center = center or false,
        Outline = true,
        OutlineColor = {0, 0, 0},
        Visible = true
    })
    return textObj
end

-- Draw line/tracer
function svlib.DrawLine(from, to, color, thickness)
    local line = svlib.GetDrawingObject("Line", {
        From = {from.x, from.y},
        To = {to.x, to.y},
        Color = color or svlib.Config.Colors.Primary,
        Thickness = thickness or 1,
        Visible = true
    })
    return line
end

----------------------------------
-- ESP Functions
----------------------------------

-- Create box ESP for a character
function svlib.CreateESP(character)
    if not character then
        print("Character inválido para ESP")
        return nil 
    end
    
    -- Check if ESP already exists for this character
    if svlib.Cache.CharacterESP[character] then
        return svlib.Cache.CharacterESP[character]
    end
    
    local success, humanoid = pcall(function() 
        return findfirstchildofclass(character, "Humanoid") 
    end)
    
    if not success or not humanoid then
        print("Humanoid não encontrado para ESP")
        return nil 
    end
    
    local rootSuccess, rootPart = pcall(function() 
        return findfirstchild(character, "HumanoidRootPart") 
    end)
    
    if not rootSuccess or not rootPart then
        print("HumanoidRootPart não encontrado para ESP")
        return nil 
    end
    
    local headSuccess, head = pcall(function() 
        return findfirstchild(character, "Head") 
    end)
    
    if not headSuccess or not head then
        print("Head não encontrado para ESP")
        return nil 
    end
    
    -- Obter posições e verificar distância
    local characterPos = getposition(rootPart)
    local distance = svlib.GetDistanceFromPlayer(characterPos)
    
    -- Check if character is within max ESP distance
    if distance > svlib.Config.Performance.MaxESPDistance then
        return nil
    end
    
    -- Ajustar procedimento de conversão para tela
    local screenSize = svlib.UpdateScreenSize()
    
    -- Get head position and convert to screen coordinates
    local headPos = getposition(head)
    local worldToScreenResult, onScreen = worldtoscreenpoint({headPos.x, headPos.y + 2, headPos.z})
    if not onScreen then
        print("Cabeça fora da tela para ESP")
        return nil
    end
    
    local topPos = {x = worldToScreenResult.x, y = worldToScreenResult.y}
    
    -- Get root position and convert to screen coordinates
    local rootPos = getposition(rootPart)
    worldToScreenResult, onScreen = worldtoscreenpoint({rootPos.x, rootPos.y - 3, rootPos.z})
    if not onScreen then
        print("Pés fora da tela para ESP")
        return nil
    end
    
    local bottomPos = {x = worldToScreenResult.x, y = worldToScreenResult.y}
    
    -- Calculate box dimensions
    local height = bottomPos.y - topPos.y
    if height <= 0 then height = 10 end -- Garantir altura mínima
    
    local width = height / 2
    
    -- Create ESP components based on config
    local espComponents = {}
    
    -- Box
    if svlib.Config.ESP.BoxType == "Corners" then
        local corners = {}
        local cornerSize = height / 4
        
        -- Top left
        table.insert(corners, svlib.DrawLine({x = topPos.x - width/2, y = topPos.y}, 
                                            {x = topPos.x - width/2 + cornerSize, y = topPos.y},
                                            svlib.Config.ESP.BoxColor, 1))
        
        table.insert(corners, svlib.DrawLine({x = topPos.x - width/2, y = topPos.y}, 
                                            {x = topPos.x - width/2, y = topPos.y + cornerSize},
                                            svlib.Config.ESP.BoxColor, 1))
        
        -- Top right
        table.insert(corners, svlib.DrawLine({x = topPos.x + width/2, y = topPos.y}, 
                                            {x = topPos.x + width/2 - cornerSize, y = topPos.y},
                                            svlib.Config.ESP.BoxColor, 1))
        
        table.insert(corners, svlib.DrawLine({x = topPos.x + width/2, y = topPos.y}, 
                                            {x = topPos.x + width/2, y = topPos.y + cornerSize},
                                            svlib.Config.ESP.BoxColor, 1))
        
        -- Bottom left
        table.insert(corners, svlib.DrawLine({x = bottomPos.x - width/2, y = bottomPos.y}, 
                                            {x = bottomPos.x - width/2 + cornerSize, y = bottomPos.y},
                                            svlib.Config.ESP.BoxColor, 1))
        
        table.insert(corners, svlib.DrawLine({x = bottomPos.x - width/2, y = bottomPos.y}, 
                                            {x = bottomPos.x - width/2, y = bottomPos.y - cornerSize},
                                            svlib.Config.ESP.BoxColor, 1))
        
        -- Bottom right
        table.insert(corners, svlib.DrawLine({x = bottomPos.x + width/2, y = bottomPos.y}, 
                                            {x = bottomPos.x + width/2 - cornerSize, y = bottomPos.y},
                                            svlib.Config.ESP.BoxColor, 1))
        
        table.insert(corners, svlib.DrawLine({x = bottomPos.x + width/2, y = bottomPos.y}, 
                                            {x = bottomPos.x + width/2, y = bottomPos.y - cornerSize},
                                            svlib.Config.ESP.BoxColor, 1))
        
        espComponents.Box = corners
    elseif svlib.Config.ESP.BoxType == "2D" then
        espComponents.Box = svlib.Draw2DBox({x = topPos.x, y = topPos.y + height/2}, 
                                           {x = width, y = height}, 
                                           svlib.Config.ESP.BoxColor, 1)
    end
    
    -- Healthbar
    if svlib.Config.ESP.HealthbarEnabled and humanoid then
        local healthData = svlib.GetHealth(humanoid)
        
        espComponents.Healthbar = svlib.DrawHealthBar(
            {x = topPos.x - width/2 - 5, y = topPos.y},
            {x = 3, y = height},
            healthData.Health,
            healthData.MaxHealth
        )
    end
    
    -- Nametag
    if svlib.Config.ESP.NametagEnabled then
        local player = nil
        for _, plr in ipairs(svlib.GetPlayers()) do
            local success, char = pcall(function() return getcharacter(plr) end)
            if success and char == character then
                player = plr
                break
            end
        end
        
        if player then
            local success, name = pcall(function() return getname(player) end)
            if success then
                espComponents.Nametag = svlib.DrawText({x = topPos.x, y = topPos.y - 20}, name, 13, svlib.Config.ESP.BoxColor, true)
            end
        end
    end
    
    -- Distance
    if svlib.Config.ESP.DistanceEnabled then
        local distanceText = string.format("%d", distance)
        espComponents.Distance = svlib.DrawText({x = bottomPos.x, y = bottomPos.y + 5}, distanceText, 13, svlib.Config.ESP.BoxColor, true)
    end
    
    -- Tracer
    if svlib.Config.ESP.TracerEnabled then
        local tracerStart = {x = screenSize.x / 2, y = screenSize.y}
        
        if svlib.Config.ESP.TracerOrigin == "Top" then
            tracerStart.y = 0
        elseif svlib.Config.ESP.TracerOrigin == "Mouse" then
            local mouse = getmouseposition()
            tracerStart.x = mouse.x
            tracerStart.y = mouse.y
        end
        
        espComponents.Tracer = svlib.DrawLine(tracerStart, {x = bottomPos.x, y = bottomPos.y}, svlib.Config.ESP.BoxColor, 1)
    end
    
    -- Store ESP components in cache for this character
    svlib.Cache.CharacterESP[character] = espComponents
    
    return espComponents
end

-- Update ESP for a specific character
function svlib.UpdateCharacterESP(character)
    if not character then 
        print("Character inválido para ESP")
        return false 
    end
    
    -- Check if character is still valid
    local success, exists = pcall(function() 
        return isdescendantof(character, svlib.GetService("Workspace")) 
    end)
    
    if not success or not exists then
        -- Character no longer exists, remove ESP
        if svlib.Cache.CharacterESP[character] then
            for _, component in pairs(svlib.Cache.CharacterESP[character]) do
                if type(component) == "table" then
                    for _, obj in pairs(component) do
                        pcall(function() if obj and obj.Remove then obj:Remove() end end)
                    end
                elseif component and component.Remove then
                    pcall(function() component:Remove() end)
                end
            end
            
            svlib.Cache.CharacterESP[character] = nil
        end
        return false
    end
    
    -- Remove old ESP and create new one to update
    if svlib.Cache.CharacterESP[character] then
        for _, component in pairs(svlib.Cache.CharacterESP[character]) do
            if type(component) == "table" then
                for _, obj in pairs(component) do
                    pcall(function() if obj and obj.Remove then obj:Remove() end end)
                end
            elseif component and component.Remove then
                pcall(function() component:Remove() end)
            end
        end
        svlib.Cache.CharacterESP[character] = nil
    end
    
    -- Create new ESP
    local result = svlib.CreateESP(character)
    return result ~= nil
end

-- Update ESP for all characters with smart drawing (only redraw when needed)
function svlib.UpdateESP()
    -- Skip if update is already in progress to prevent overlapping
    if svlib.Cache.UpdateInProgress or not svlib.Config.ESP.Enabled then return end
    svlib.Cache.UpdateInProgress = true
    
    -- Incrementar contagem de frames para limitar a limpeza
    svlib.Cache.FrameCount = svlib.Cache.FrameCount + 1
    
    -- Fazer limpeza periódica (a cada 50 frames)
    if svlib.Cache.FrameCount >= 50 then
        svlib.Cache.FrameCount = 0
        svlib.CleanupInvalidDrawings()
    end
    
    -- Get local player
    local localPlayer = svlib.GetLocalPlayer()
    if not localPlayer then 
        svlib.Cache.UpdateInProgress = false
        return 
    end
    
    -- Get all characters
    local characters = {}
    local players = svlib.GetPlayers()
    
    for _, player in ipairs(players) do
        if player ~= localPlayer then
            local success, character = pcall(function() return getcharacter(player) end)
            if success and character then
                table.insert(characters, character)
            end
        end
    end
    
    -- Update existing ESP or create new ones
    for _, character in ipairs(characters) do
        -- Check if character is still valid before updating
        local success, exists = pcall(function() 
            return isdescendantof(character, svlib.GetService("Workspace")) 
        end)
        
        if success and exists then
            -- Não atualizar o ESP a cada frame para o mesmo personagem
            -- Verificar se já tem ESP e se foi atualizado recentemente
            local hasESP = svlib.Cache.CharacterESP[character] ~= nil
            
            if not hasESP then
                svlib.CreateESP(character)
            elseif svlib.Cache.FrameCount % 3 == 0 then
                -- Atualizar apenas 1/3 dos personagens a cada frame para suavizar
                svlib.UpdateCharacterESP(character)
            end
        elseif svlib.Cache.CharacterESP[character] then
            -- Character não existe mais, mover objetos para o pool em vez de destruir
            for _, component in pairs(svlib.Cache.CharacterESP[character]) do
                if type(component) == "table" then
                    for _, obj in pairs(component) do
                        if obj and obj.Visible ~= nil then
                            pcall(function() 
                                obj.Visible = false
                                table.insert(svlib.Cache.DrawingPool, obj)
                            end)
                        end
                    end
                elseif component and component.Visible ~= nil then
                    pcall(function() 
                        component.Visible = false 
                        table.insert(svlib.Cache.DrawingPool, component)
                    end)
                end
            end
            
            svlib.Cache.CharacterESP[character] = nil
        end
    end
    
    -- Update stats
    svlib.Stats.ObjectsDrawn = #svlib.Cache.DrawingObjects
    svlib.Stats.FrameTime = time() - svlib.Stats.LastUpdate
    svlib.Stats.LastUpdate = time()
    
    svlib.Cache.UpdateInProgress = false
end

----------------------------------
-- Aimbot Functions
----------------------------------

-- Get closest visible player
function svlib.GetClosestVisiblePlayer()
    local localPlayer = svlib.GetLocalPlayer()
    local localCharacter = getcharacter(localPlayer)
    if not localCharacter then return nil end
    
    local localHead = findfirstchild(localCharacter, "Head")
    if not localHead then return nil end
    
    local localHeadPos = getposition(localHead)
    local closestDistance = math.huge
    local targetPlayer = nil
    local targetPart = nil
    
    for _, player in ipairs(svlib.GetPlayers()) do
        if player ~= localPlayer then
            local character = getcharacter(player)
            if character then
                local humanoid = findfirstchildofclass(character, "Humanoid")
                if humanoid and gethealth(humanoid) > 0 then
                    local part = findfirstchild(character, svlib.Config.Aimbot.TargetPart)
                    if part then
                        local partPos = getposition(part)
                        local distance = svlib.GetDistance(localHeadPos, partPos)
                        
                        if distance < closestDistance and distance <= svlib.Config.Aimbot.FOV then
                            -- Check if target is visible
                            local screenPos, visible = worldtoscreenpoint({partPos.x, partPos.y, partPos.z})
                            if visible then
                                closestDistance = distance
                                targetPlayer = player
                                targetPart = part
                            end
                        end
                    end
                end
            end
        end
    end
    
    return targetPlayer, targetPart
end

-- Aim at target
function svlib.AimAtTarget(targetPart)
    if not targetPart then return end
    
    local targetPos = getposition(targetPart)
    local screenPos, visible = worldtoscreenpoint({targetPos.x, targetPos.y, targetPos.z})
    
    if visible then
        local mousePos = getmouseposition()
        local aimPos = {screenPos.x, screenPos.y}
        
        -- Apply smooth aim
        local result = smoothmouse_linear({mousePos.x, mousePos.y}, aimPos, 1, svlib.Config.Aimbot.Smoothness)
        mousemoverel(result.x, result.y)
    end
end

-- Aimbot update function
function svlib.UpdateAimbot()
    if not svlib.Config.Aimbot.Enabled then return end
    
    local _, targetPart = svlib.GetClosestVisiblePlayer()
    if targetPart then
        svlib.AimAtTarget(targetPart)
    end
end

----------------------------------
-- Core Loop Function
----------------------------------

-- Run cleanup routine periodically
function svlib.ScheduleCleanup()
    spawn(function()
        while true do
            -- Run cleanup every few seconds
            wait(svlib.Config.Performance.CleanRate)
            
            if svlib.Config.ESP.Enabled then
                svlib.CleanupInvalidDrawings()
            end
        end
    end)
end

-- Optimized main loop with error handling
function svlib.RunMainLoop()
    -- Parar loop anterior se existir
    svlib.StopMainLoop()
    
    -- Iniciar novo loop
    svlib.Cache.ThreadActive = true
    
    -- Thread principal separada
    spawn(function()
        while svlib.Cache.ThreadActive do
            pcall(function()
                if svlib.Config.ESP.Enabled then
                    svlib.UpdateESP()
                elseif #svlib.Cache.DrawingObjects > 0 then
                    -- Limpar desenhos se ESP estiver desativado
                    svlib.ClearDrawings(false)
                end
            end)
            
            -- Usar taxa de atualização estável
            wait(svlib.Config.Performance.UpdateRate)
        end
    end)
    
    -- Thread separada para aimbot (reduz interferência)
    spawn(function()
        while svlib.Cache.ThreadActive do
            pcall(function()
                if svlib.Config.Aimbot.Enabled then
                    svlib.UpdateAimbot()
                end
            end)
            
            -- Taxa de atualização mais rápida para o aimbot
            wait(0.01)
        end
    end)
    
    -- Thread separada para limpeza preventiva (não bloqueante)
    spawn(function()
        while svlib.Cache.ThreadActive do
            wait(3) -- Limpeza a cada 3 segundos
            
            -- Limitar o número de objetos criados para evitar sobrecarga
            if #svlib.Cache.DrawingObjects > svlib.Config.Performance.MaxDrawObjects * 0.8 then
                -- Se estiver próximo do limite, fazer uma limpeza parcial
                svlib.CleanupInvalidDrawings()
            end
        end
    end)
end

-- Stop current loop
function svlib.StopMainLoop()
    svlib.Cache.ThreadActive = false
end

-- Initialize the library
function svlib.Init()
    print("Severe Library initialized!")
    
    -- Garantir que o anti-crash esteja ativado
    svlib.Config.Performance.EnableAntiCrash = true
    
    -- Atualizar tamanho da tela
    svlib.UpdateScreenSize()
    
    -- Limpar desenhos existentes
    svlib.ClearDrawings(true)
    
    -- Iniciar loop principal
    svlib.RunMainLoop()
    
    return svlib
end

-- Return the library
return svlib 
