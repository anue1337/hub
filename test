--[[
    Severe Library v1.0.0
    A comprehensive utility library for script development with built-in ESP capabilities
]]

local SevereLib = {}
SevereLib.__index = SevereLib

-- Internal variables
local drawingNew = Drawing.new
local mathFloor, mathSqrt = math.floor, math.sqrt
local camera = workspace:FindFirstChild('Camera')
local localPlayer = game:GetService("Players").LocalPlayer
local stop = false
local espObjects = {
    players = {},
    items = {},
    entities = {},
    custom = {}
}

-- Console Functions
SevereLib.Console = {}

-- Shows the Severe console for debugging
function SevereLib.Console:Show()
    -- Implementation depends on GUI system
    print("[Severe] Console shown")
    return true
end

-- Print to Severe console with optional formatting
function SevereLib.Console:Print(...)
    local args = {...}
    local message = ""
    
    for i, v in ipairs(args) do
        if type(v) == "table" then
            message = message .. table.concat(v, ", ")
        else
            message = message .. tostring(v)
        end
        
        if i < #args then
            message = message .. " "
        end
    end
    
    print("[Severe] " .. message)
    return true
end

-- Show error in Severe console
function SevereLib.Console:Error(message)
    warn("[Severe] ERROR: " .. tostring(message))
    return true
end

-- General Functions
-- Navigate through game instances easily (similar to DXLib.Game)
function SevereLib:Game(...)
    local args = {...}
    local current = game
    
    for _, path in ipairs(args) do
        current = current:FindFirstChild(path)
        if not current then
            return nil
        end
    end
    
    return current
end

-- Get closest part from parts collection to the origin point
function SevereLib:GetClosestPart(origin, parts)
    if not origin or not parts then return nil end
    
    local closest, distance = nil, math.huge
    
    for _, part in ipairs(parts) do
        local partPos = part.Position
        local dist = (partPos - origin).Magnitude
        
        if dist < distance then
            closest = part
            distance = dist
        end
    end
    
    return closest, distance
end

-- Get all descendants of an instance
function SevereLib:GetDescendants(instance)
    if not instance then return {} end
    return instance:GetDescendants()
end

-- Get descendants of a specific class from an instance
function SevereLib:GetDescendantsOfClass(instance, className)
    if not instance or not className then return {} end
    
    local results = {}
    
    for _, desc in ipairs(instance:GetDescendants()) do
        if desc:IsA(className) then
            table.insert(results, desc)
        end
    end
    
    return results
end

-- Calculate distance between two Vector3 positions
function SevereLib:GetDistance(pos1, pos2)
    if not pos1 or not pos2 then return 0 end
    
    local dx, dy, dz = pos1.X - pos2.X, pos1.Y - pos2.Y, pos1.Z - pos2.Z
    return mathSqrt(dx * dx + dy * dy + dz * dz)
end

-- Calculate distance from a position to the local player
function SevereLib:GetDistanceFromPlayer(position)
    if not position or not localPlayer.Character then return 0 end
    
    local rootPart = localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return 0 end
    
    return SevereLib:GetDistance(rootPart.Position, position)
end

-- Get local player character
function SevereLib:GetLocalCharacter()
    if not localPlayer then return nil end
    return localPlayer.Character
end

-- Get local player
function SevereLib:GetLocalPlayer()
    return localPlayer
end

-- Get player by name or display name
function SevereLib:GetPlayer(name)
    if not name then return nil end
    
    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        if player.Name:lower() == name:lower() or player.DisplayName:lower() == name:lower() then
            return player
        end
    end
    
    return nil
end

-- Check if mouse is in a rectangular area of the screen
function SevereLib:IsMouseInArea(x1, y1, x2, y2)
    local mouse = game:GetService("UserInputService"):GetMouseLocation()
    return mouse.X >= x1 and mouse.X <= x2 and mouse.Y >= y1 and mouse.Y <= y2
end

-- Convert JSON string to table
function SevereLib:JsonToTable(jsonString)
    if not jsonString then return {} end
    
    local success, result = pcall(function()
        return game:GetService("HttpService"):JSONDecode(jsonString)
    end)
    
    if success then
        return result
    else
        SevereLib.Console:Error("Failed to parse JSON: " .. result)
        return {}
    end
end

-- Convert table to JSON string
function SevereLib:TableToJson(tbl)
    if not tbl then return "{}" end
    
    local success, result = pcall(function()
        return game:GetService("HttpService"):JSONEncode(tbl)
    end)
    
    if success then
        return result
    else
        SevereLib.Console:Error("Failed to encode JSON: " .. result)
        return "{}"
    end
end

-- ESP Functions
SevereLib.ESP = {}

-- Create new drawing object with specified properties
local function createDrawingObject(class, props)
    local obj = drawingNew(class)
    
    for property, value in pairs(props) do
        obj[property] = value
    end
    
    return obj
end

-- Create ESP visual elements for an object
local function createEspElements(color, radius, showTracer)
    local elements = {
        text = createDrawingObject('Text', {
            Text = '', 
            Size = 14, 
            Font = 2, 
            Color = color,
            Center = true, 
            Outline = true, 
            Visible = false, 
            Transparency = 1
        }),
        circle = createDrawingObject('Circle', {
            Radius = radius or 5, 
            Thickness = 1, 
            NumSides = 12, 
            Filled = true,
            Color = color, 
            Transparency = 0.8, 
            Visible = false
        })
    }
    
    if showTracer then
        elements.tracer = createDrawingObject('Line', {
            Thickness = 1,
            Color = color,
            Transparency = 0.6,
            Visible = false
        })
    end
    
    return elements
end

-- Update ESP elements based on camera position and target position
local function updateEspObject(espObject, camPos, maxDistance, drawDistance)
    local rootPart = espObject.root
    
    if not rootPart then
        return false
    end
    
    local screenPos, isOnScreen = workspace.CurrentCamera:WorldToScreenPoint(rootPart.Position)
    local distance = mathFloor((rootPart.Position - camPos).Magnitude)
    
    if isOnScreen and distance <= maxDistance then
        local displayName = drawDistance 
            and espObject.name .. ' [' .. tostring(distance) .. 'm]' 
            or espObject.name
        
        espObject.text.Text = displayName
        espObject.text.Position = Vector2.new(screenPos.X, screenPos.Y + 10)
        espObject.text.Color = espObject.custom_color
        espObject.text.Visible = true
        
        espObject.circle.Position = Vector2.new(screenPos.X, screenPos.Y)
        espObject.circle.Color = espObject.custom_color
        espObject.circle.Visible = true
        
        if espObject.tracer then
            espObject.tracer.From = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y)
            espObject.tracer.To = Vector2.new(screenPos.X, screenPos.Y)
            espObject.tracer.Color = espObject.custom_color
            espObject.tracer.Visible = true
        end
        
        return true
    else
        espObject.text.Visible = false
        espObject.circle.Visible = false
        
        if espObject.tracer then
            espObject.tracer.Visible = false
        end
        
        return false
    end
end

-- Main ESP update function
local function updateEsp()
    while not stop do
        local camPos = workspace.CurrentCamera.CFrame.Position
        
        for espType, objects in pairs(espObjects) do
            local config = SevereLib.ESP.Config[espType] or SevereLib.ESP.Config.default
            
            if config.enabled then
                for index, object in pairs(objects) do
                    if not object.root or not object.root:IsDescendantOf(workspace) then
                        -- Clean up if object no longer exists
                        if object.text then object.text:Remove() end
                        if object.circle then object.circle:Remove() end
                        if object.tracer then object.tracer:Remove() end
                        objects[index] = nil
                    else
                        updateEspObject(object, camPos, config.maxDistance, config.drawDistance)
                    end
                end
            else
                -- Hide all objects of this type if disabled
                for _, object in pairs(objects) do
                    if object.text then object.text.Visible = false end
                    if object.circle then object.circle.Visible = false end
                    if object.tracer then object.tracer.Visible = false end
                end
            end
        end
        
        wait(1/60) -- Update at 60fps
    end
    
    -- Clean up all drawings when stopped
    for _, objects in pairs(espObjects) do
        for _, object in pairs(objects) do
            if object.text then object.text:Remove() end
            if object.circle then object.circle:Remove() end
            if object.tracer then object.tracer:Remove() end
        end
    end
end

-- Default ESP configuration
SevereLib.ESP.Config = {
    default = {
        enabled = true,
        maxDistance = 1000,
        drawDistance = true,
        color = {255, 255, 255},
        radius = 5,
        showTracer = false
    },
    players = {
        enabled = true,
        maxDistance = 1000,
        drawDistance = true,
        color = {255, 0, 0},
        radius = 5,
        showTracer = true,
        showTeam = false
    },
    items = {
        enabled = true,
        maxDistance = 400,
        drawDistance = true,
        color = {235, 237, 143},
        radius = 5,
        showTracer = false
    },
    entities = {
        enabled = true,
        maxDistance = 500,
        drawDistance = true,
        color = {0, 255, 0},
        radius = 5,
        showTracer = false
    },
    custom = {
        enabled = true,
        maxDistance = 1000,
        drawDistance = true,
        color = {0, 255, 255},
        radius = 5,
        showTracer = false
    }
}

-- BoxESP - Create an ESP box, name, tracer for target
function SevereLib.ESP:BoxESP(options)
    if not options or not options.Target then
        SevereLib.Console:Error("BoxESP requires a Target parameter")
        return nil
    end
    
    local target = options.Target
    local espType = options.Type or "custom"
    local config = SevereLib.ESP.Config[espType] or SevereLib.ESP.Config.default
    
    -- Get target root part
    local rootPart
    if target:IsA("Model") then
        rootPart = target:FindFirstChild("HumanoidRootPart") or target:FindFirstChild("PrimaryPart")
        
        if not rootPart then
            for _, child in ipairs(target:GetChildren()) do
                if child:IsA("BasePart") then
                    rootPart = child
                    break
                end
            end
        end
    elseif target:IsA("BasePart") then
        rootPart = target
    end
    
    if not rootPart then
        SevereLib.Console:Error("BoxESP target must have a valid part")
        return nil
    end
    
    -- Set up color
    local color = options.Color or config.color
    if type(color) == "table" and #color >= 3 then
        color = Color3.fromRGB(color[1], color[2], color[3])
    end
    
    -- Create ESP elements
    local elements = createEspElements(
        color, 
        options.Radius or config.radius,
        options.Tracer or config.showTracer
    )
    
    -- Build ESP object
    local espObject = {
        root = rootPart,
        name = options.Name or target.Name,
        text = elements.text,
        circle = elements.circle,
        tracer = elements.tracer,
        custom_color = color
    }
    
    -- Add to appropriate collection
    table.insert(espObjects[espType], espObject)
    
    return espObject
end

-- Initialize a 2D box ESP (corners only)
function SevereLib.ESP:Box2D(options)
    if not options or not options.Target then
        SevereLib.Console:Error("Box2D requires a Target parameter")
        return nil
    end
    
    -- Box2D implementation would go here
    -- Similar to BoxESP but with different visual style
    -- Using Corner points instead of a full box
    
    return SevereLib.ESP:BoxESP({
        Target = options.Target,
        Type = options.Type or "custom",
        Color = options.Color,
        Name = options.Name,
        BoxType = 2 -- 2D box style
    })
end

-- Initialize a 3D box ESP
function SevereLib.ESP:Box3D(options)
    if not options or not options.Target then
        SevereLib.Console:Error("Box3D requires a Target parameter")
        return nil
    end
    
    -- Box3D implementation would go here
    -- Similar to BoxESP but with 3D box rendering
    
    return SevereLib.ESP:BoxESP({
        Target = options.Target,
        Type = options.Type or "custom",
        Color = options.Color,
        Name = options.Name,
        BoxType = 3 -- 3D box style
    })
end

-- Add health bar to ESP object
function SevereLib.ESP:HealthBar(espObject, humanoid)
    if not espObject or not humanoid then
        SevereLib.Console:Error("HealthBar requires both espObject and humanoid")
        return false
    end
    
    -- HealthBar implementation would go here
    -- Add health bar visual elements to existing espObject
    
    return true
end

-- Start the ESP system
function SevereLib.ESP:Start()
    if stop then
        stop = false
        spawn(updateEsp)
        SevereLib.Console:Print("ESP system started")
    end
    return true
end

-- Stop the ESP system and clean up
function SevereLib.ESP:Stop()
    stop = true
    SevereLib.Console:Print("ESP system stopped")
    return true
end

-- Utility function to add players to ESP
function SevereLib.ESP:AddAllPlayers(options)
    options = options or {}
    local players = game:GetService("Players"):GetPlayers()
    
    for _, player in ipairs(players) do
        if player ~= localPlayer then
            spawn(function()
                local character = player.Character
                if character then
                    SevereLib.ESP:BoxESP({
                        Target = character,
                        Type = "players",
                        Name = player.Name,
                        Color = options.Color,
                        Tracer = options.Tracer
                    })
                end
            end)
        end
    end
    
    return true
end

-- Utility function to add a custom object to ESP
function SevereLib.ESP:AddCustomObject(object, name, color, type)
    if not object then return nil end
    
    return SevereLib.ESP:BoxESP({
        Target = object,
        Type = type or "custom",
        Name = name or object.Name,
        Color = color
    })
end

-- Create UI Elements
SevereLib.UI = {}

-- Create a new window
function SevereLib.UI:Window(options)
    options = options or {}
    -- UI window implementation would go here
    -- This would be a placeholder for a UI library implementation
    SevereLib.Console:Print("Created UI Window: " .. (options.Title or "Untitled"))
    return {}
end

-- Initialize the library
function SevereLib:Init()
    SevereLib.Console:Print("Severe Library initialized")
    return self
end

-- Unload the library and clean up
function SevereLib:Unload()
    SevereLib.ESP:Stop()
    stop = true
    
    -- Clean up ESP objects
    for _, objects in pairs(espObjects) do
        for _, object in pairs(objects) do
            if object.text then object.text:Remove() end
            if object.circle then object.circle:Remove() end
            if object.tracer then object.tracer:Remove() end
        end
    end
    
    SevereLib.Console:Print("Severe Library unloaded")
    return true
end

return SevereLib:Init()
