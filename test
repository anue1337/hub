--[[
    Severe Library - An optimized utility library for Severe
    
    Features:
    - Optimized ESP functionality
    - Game object utilities
    - Mouse/input helpers
    - Distance calculations
    - Drawing utilities
]]

-- Initialize library
if not _G.svlib then
    _G.svlib = {
        -- Configuration
        Config = {
            ESP = {
                BoxColor = {255, 255, 255},
                HealthbarEnabled = true,
                NametagEnabled = true,
                DistanceEnabled = true,
                TracerEnabled = false,
                TracerOrigin = "Bottom", -- "Bottom", "Top", "Mouse"
                BoxType = "Corners", -- "Corners", "2D", "3D"
            },
            Aimbot = {
                Enabled = false,
                Smoothness = 0.5,
                FOV = 100,
                TargetPart = "Head",
            },
            Colors = {
                Primary = {255, 255, 255},
                Secondary = {25, 25, 25},
                Accent = {255, 0, 0},
                Background = {15, 15, 15},
                Warning = {255, 200, 0},
                Error = {255, 50, 50},
                Success = {0, 255, 50},
            },
            Performance = {
                MaxESPDistance = 1000,
                MaxDrawObjects = 500,
            },
        },
        
        -- Cache for optimization
        Cache = {
            PlayerData = {},
            DrawingObjects = {},
            LocalPlayer = nil,
            Camera = nil,
            ScreenSize = {x = 0, y = 0},
        },
        
        -- Stats for debugging
        Stats = {
            FrameTime = 0,
            ObjectsDrawn = 0,
            LastUpdate = 0,
        },
    }
end

-- Reference to the library
local svlib = _G.svlib

-- Shorthand to Game
local Game = Game

----------------------------------
-- Utility Functions
----------------------------------

-- Get screen dimensions
function svlib.UpdateScreenSize()
    local dims = getscreendimensions()
    svlib.Cache.ScreenSize = {x = dims.x, y = dims.y}
    return svlib.Cache.ScreenSize
end

-- Check if mouse is in an area
function svlib.IsMouseInArea(x1, y1, x2, y2)
    local mouse = getmouseposition()
    return (mouse.x >= x1 and mouse.x <= x2 and mouse.y >= y1 and mouse.y <= y2)
end

-- Get distance between two positions
function svlib.GetDistance(pos1, pos2)
    local x = pos1.x - pos2.x
    local y = pos1.y - pos2.y
    local z = pos1.z - pos2.z
    return math.sqrt(x*x + y*y + z*z)
end

-- Get distance from position to player
function svlib.GetDistanceFromPlayer(pos)
    local character = getcharacter(getlocalplayer())
    if not character then return 0 end
    
    local rootPart = findfirstchild(character, "HumanoidRootPart")
    if not rootPart then return 0 end
    
    local playerPos = getposition(rootPart)
    return svlib.GetDistance(playerPos, pos)
end

-- Get game service
function svlib.GetService(serviceName)
    return findservice(Game, serviceName)
end

-- Navigate Game path easily
function svlib.Game(...)
    local current = Game
    local args = {...}
    
    for _, path in ipairs(args) do
        current = findfirstchild(current, path)
        if not current then return nil end
    end
    
    return current
end

-- Get descendants
function svlib.GetDescendants(instance)
    local result = {}
    local function addDescendants(parent)
        local children = getchildren(parent)
        for _, child in ipairs(children) do
            table.insert(result, child)
            addDescendants(child)
        end
    end
    
    addDescendants(instance)
    return result
end

-- Get descendants of class
function svlib.GetDescendantsOfClass(instance, className)
    local result = {}
    
    for _, descendant in ipairs(svlib.GetDescendants(instance)) do
        if getclassname(descendant) == className then
            table.insert(result, descendant)
        end
    end
    
    return result
end

-- Find closest part in a model
function svlib.GetClosestPart(model)
    local parts = {}
    local validClasses = {
        ["Part"] = true,
        ["MeshPart"] = true,
        ["TrussPart"] = true,
        ["WedgePart"] = true,
    }
    
    for _, descendant in ipairs(svlib.GetDescendants(model)) do
        local className = getclassname(descendant)
        if validClasses[className] then
            table.insert(parts, descendant)
        end
    end
    
    local closestDistance = math.huge
    local closestPart = nil
    
    for _, part in ipairs(parts) do
        local distance = svlib.GetDistanceFromPlayer(getposition(part))
        if distance < closestDistance then
            closestDistance = distance
            closestPart = part
        end
    end
    
    return closestPart
end

----------------------------------
-- Player Functions
----------------------------------

-- Get local player
function svlib.GetLocalPlayer()
    if not svlib.Cache.LocalPlayer then
        svlib.Cache.LocalPlayer = getlocalplayer()
    end
    return svlib.Cache.LocalPlayer
end

-- Get local character
function svlib.GetLocalCharacter()
    local player = svlib.GetLocalPlayer()
    return getcharacter(player)
end

-- Get player by name
function svlib.GetPlayer(name)
    local players = svlib.GetService("Players")
    local children = getchildren(players)
    
    for _, player in ipairs(children) do
        if getname(player) == name then
            return player
        end
    end
    
    return nil
end

-- Get all players
function svlib.GetPlayers()
    local players = svlib.GetService("Players")
    return getchildren(players)
end

-- Check if player is an enemy
function svlib.IsEnemy(player)
    local localPlayer = svlib.GetLocalPlayer()
    local localTeam = getteam(localPlayer)
    local playerTeam = getteam(player)
    
    if not localTeam or not playerTeam then return true end
    return localTeam ~= playerTeam
end

-- Get humanoid health
function svlib.GetHealth(humanoid)
    return {
        Health = gethealth(humanoid),
        MaxHealth = getmaxhealth(humanoid)
    }
end

----------------------------------
-- Drawing Functions
----------------------------------

-- Initialize a new cached drawing object
function svlib.NewDrawing(drawingType, properties)
    -- Create the drawing object
    local drawing = Drawing.new(drawingType)
    
    -- Set the properties
    for property, value in pairs(properties or {}) do
        drawing[property] = value
    end
    
    -- Add to cache for management
    table.insert(svlib.Cache.DrawingObjects, drawing)
    
    -- Return the drawing object
    return drawing
end

-- Clear all drawing objects
function svlib.ClearDrawings()
    for _, drawing in ipairs(svlib.Cache.DrawingObjects) do
        drawing:Remove()
    end
    svlib.Cache.DrawingObjects = {}
end

-- Remove a specific drawing object
function svlib.RemoveDrawing(drawing)
    for i, obj in ipairs(svlib.Cache.DrawingObjects) do
        if obj == drawing then
            obj:Remove()
            table.remove(svlib.Cache.DrawingObjects, i)
            break
        end
    end
end

-- Draw a 2D box
function svlib.Draw2DBox(position, size, color, thickness)
    local box = svlib.NewDrawing("Square", {
        Position = {position.x - size.x/2, position.y - size.y/2},
        Size = {size.x, size.y},
        Color = color or svlib.Config.Colors.Primary,
        Thickness = thickness or 1,
        Filled = false,
        Visible = true
    })
    return box
end

-- Draw a health bar
function svlib.DrawHealthBar(position, size, health, maxHealth)
    local background = svlib.NewDrawing("Square", {
        Position = {position.x, position.y},
        Size = {size.x, size.y},
        Color = {0, 0, 0},
        Filled = true,
        Visible = true
    })
    
    local healthRatio = math.min(1, health / maxHealth)
    local healthColor = {
        255 * (1 - healthRatio),
        255 * healthRatio,
        0
    }
    
    local fill = svlib.NewDrawing("Square", {
        Position = {position.x, position.y},
        Size = {size.x * healthRatio, size.y},
        Color = healthColor,
        Filled = true,
        Visible = true
    })
    
    return {
        Background = background,
        Fill = fill
    }
end

-- Draw text
function svlib.DrawText(position, text, size, color, center)
    local textObj = svlib.NewDrawing("Text", {
        Position = {position.x, position.y},
        Text = text,
        Size = size or 13,
        Color = color or svlib.Config.Colors.Primary,
        Center = center or false,
        Outline = true,
        OutlineColor = {0, 0, 0},
        Visible = true
    })
    return textObj
end

-- Draw line/tracer
function svlib.DrawLine(from, to, color, thickness)
    local line = svlib.NewDrawing("Line", {
        From = {from.x, from.y},
        To = {to.x, to.y},
        Color = color or svlib.Config.Colors.Primary,
        Thickness = thickness or 1,
        Visible = true
    })
    return line
end

----------------------------------
-- ESP Functions
----------------------------------

-- Create box ESP for a character
function svlib.CreateESP(character)
    if not character then return nil end
    
    local humanoid = findfirstchildofclass(character, "Humanoid")
    if not humanoid then return nil end
    
    local rootPart = findfirstchild(character, "HumanoidRootPart")
    if not rootPart then return nil end
    
    local head = findfirstchild(character, "Head")
    if not head then return nil end
    
    local characterPos = getposition(rootPart)
    local distance = svlib.GetDistanceFromPlayer(characterPos)
    
    -- Check if character is within max ESP distance
    if distance > svlib.Config.Performance.MaxESPDistance then
        return nil
    end
    
    -- Determine box dimensions based on character size
    local headPos = getposition(head)
    local rootPos = getposition(rootPart)
    local size = getsize(rootPart)
    
    local screenSize = svlib.UpdateScreenSize()
    
    local worldToScreenResult, onScreen = worldtoscreenpoint({headPos.x, headPos.y + 2, headPos.z})
    if not onScreen then return nil end
    
    local topPos = {x = worldToScreenResult.x, y = worldToScreenResult.y}
    
    worldToScreenResult, onScreen = worldtoscreenpoint({rootPos.x, rootPos.y - 3, rootPos.z})
    if not onScreen then return nil end
    
    local bottomPos = {x = worldToScreenResult.x, y = worldToScreenResult.y}
    
    local height = bottomPos.y - topPos.y
    local width = height / 2
    
    -- Create ESP components based on config
    local espComponents = {}
    
    -- Box
    if svlib.Config.ESP.BoxType == "Corners" then
        local corners = {}
        local cornerSize = height / 4
        
        -- Top left
        table.insert(corners, svlib.DrawLine({x = topPos.x - width/2, y = topPos.y}, 
                                            {x = topPos.x - width/2 + cornerSize, y = topPos.y},
                                            svlib.Config.ESP.BoxColor, 1))
        
        table.insert(corners, svlib.DrawLine({x = topPos.x - width/2, y = topPos.y}, 
                                            {x = topPos.x - width/2, y = topPos.y + cornerSize},
                                            svlib.Config.ESP.BoxColor, 1))
        
        -- Top right
        table.insert(corners, svlib.DrawLine({x = topPos.x + width/2, y = topPos.y}, 
                                            {x = topPos.x + width/2 - cornerSize, y = topPos.y},
                                            svlib.Config.ESP.BoxColor, 1))
        
        table.insert(corners, svlib.DrawLine({x = topPos.x + width/2, y = topPos.y}, 
                                            {x = topPos.x + width/2, y = topPos.y + cornerSize},
                                            svlib.Config.ESP.BoxColor, 1))
        
        -- Bottom left
        table.insert(corners, svlib.DrawLine({x = bottomPos.x - width/2, y = bottomPos.y}, 
                                            {x = bottomPos.x - width/2 + cornerSize, y = bottomPos.y},
                                            svlib.Config.ESP.BoxColor, 1))
        
        table.insert(corners, svlib.DrawLine({x = bottomPos.x - width/2, y = bottomPos.y}, 
                                            {x = bottomPos.x - width/2, y = bottomPos.y - cornerSize},
                                            svlib.Config.ESP.BoxColor, 1))
        
        -- Bottom right
        table.insert(corners, svlib.DrawLine({x = bottomPos.x + width/2, y = bottomPos.y}, 
                                            {x = bottomPos.x + width/2 - cornerSize, y = bottomPos.y},
                                            svlib.Config.ESP.BoxColor, 1))
        
        table.insert(corners, svlib.DrawLine({x = bottomPos.x + width/2, y = bottomPos.y}, 
                                            {x = bottomPos.x + width/2, y = bottomPos.y - cornerSize},
                                            svlib.Config.ESP.BoxColor, 1))
        
        espComponents.Box = corners
    elseif svlib.Config.ESP.BoxType == "2D" then
        espComponents.Box = svlib.Draw2DBox({x = topPos.x, y = topPos.y + height/2}, 
                                           {x = width, y = height}, 
                                           svlib.Config.ESP.BoxColor, 1)
    end
    
    -- Healthbar
    if svlib.Config.ESP.HealthbarEnabled and humanoid then
        local health = gethealth(humanoid)
        local maxHealth = getmaxhealth(humanoid)
        
        espComponents.Healthbar = svlib.DrawHealthBar(
            {x = topPos.x - width/2 - 5, y = topPos.y},
            {x = 3, y = height},
            health,
            maxHealth
        )
    end
    
    -- Nametag
    if svlib.Config.ESP.NametagEnabled then
        local player = nil
        for _, plr in ipairs(svlib.GetPlayers()) do
            if getcharacter(plr) == character then
                player = plr
                break
            end
        end
        
        if player then
            local name = getname(player)
            espComponents.Nametag = svlib.DrawText({x = topPos.x, y = topPos.y - 20}, name, 13, svlib.Config.ESP.BoxColor, true)
        end
    end
    
    -- Distance
    if svlib.Config.ESP.DistanceEnabled then
        local distanceText = string.format("%d", distance)
        espComponents.Distance = svlib.DrawText({x = bottomPos.x, y = bottomPos.y + 5}, distanceText, 13, svlib.Config.ESP.BoxColor, true)
    end
    
    -- Tracer
    if svlib.Config.ESP.TracerEnabled then
        local tracerStart = {x = screenSize.x / 2, y = screenSize.y}
        
        if svlib.Config.ESP.TracerOrigin == "Top" then
            tracerStart.y = 0
        elseif svlib.Config.ESP.TracerOrigin == "Mouse" then
            local mouse = getmouseposition()
            tracerStart.x = mouse.x
            tracerStart.y = mouse.y
        end
        
        espComponents.Tracer = svlib.DrawLine(tracerStart, {x = bottomPos.x, y = bottomPos.y}, svlib.Config.ESP.BoxColor, 1)
    end
    
    return espComponents
end

-- Update ESP for all characters
function svlib.UpdateESP()
    -- Clear existing drawings
    svlib.ClearDrawings()
    
    local workspace = svlib.GetService("Workspace")
    local localPlayer = svlib.GetLocalPlayer()
    local localCharacter = getcharacter(localPlayer)
    
    -- Find all characters
    local characters = {}
    for _, player in ipairs(svlib.GetPlayers()) do
        if player ~= localPlayer then
            local character = getcharacter(player)
            if character then
                table.insert(characters, character)
            end
        end
    end
    
    -- Add ESP to each character
    for _, character in ipairs(characters) do
        svlib.CreateESP(character)
    end
    
    -- Update stats
    svlib.Stats.ObjectsDrawn = #svlib.Cache.DrawingObjects
    svlib.Stats.FrameTime = time() - svlib.Stats.LastUpdate
    svlib.Stats.LastUpdate = time()
end

----------------------------------
-- Aimbot Functions
----------------------------------

-- Get closest visible player
function svlib.GetClosestVisiblePlayer()
    local localPlayer = svlib.GetLocalPlayer()
    local localCharacter = getcharacter(localPlayer)
    if not localCharacter then return nil end
    
    local localHead = findfirstchild(localCharacter, "Head")
    if not localHead then return nil end
    
    local localHeadPos = getposition(localHead)
    local closestDistance = math.huge
    local targetPlayer = nil
    local targetPart = nil
    
    for _, player in ipairs(svlib.GetPlayers()) do
        if player ~= localPlayer and svlib.IsEnemy(player) then
            local character = getcharacter(player)
            if character then
                local humanoid = findfirstchildofclass(character, "Humanoid")
                if humanoid and gethealth(humanoid) > 0 then
                    local part = findfirstchild(character, svlib.Config.Aimbot.TargetPart)
                    if part then
                        local partPos = getposition(part)
                        local distance = svlib.GetDistance(localHeadPos, partPos)
                        
                        if distance < closestDistance and distance <= svlib.Config.Aimbot.FOV then
                            -- Check if target is visible
                            local screenPos, visible = worldtoscreenpoint({partPos.x, partPos.y, partPos.z})
                            if visible then
                                closestDistance = distance
                                targetPlayer = player
                                targetPart = part
                            end
                        end
                    end
                end
            end
        end
    end
    
    return targetPlayer, targetPart
end

-- Aim at target
function svlib.AimAtTarget(targetPart)
    if not targetPart then return end
    
    local targetPos = getposition(targetPart)
    local screenPos, visible = worldtoscreenpoint({targetPos.x, targetPos.y, targetPos.z})
    
    if visible then
        local mousePos = getmouseposition()
        local aimPos = {screenPos.x, screenPos.y}
        
        -- Apply smooth aim
        local result = smoothmouse_linear({mousePos.x, mousePos.y}, aimPos, 1, svlib.Config.Aimbot.Smoothness)
        mousemoverel(result.x, result.y)
    end
end

-- Aimbot update function
function svlib.UpdateAimbot()
    if not svlib.Config.Aimbot.Enabled then return end
    
    local _, targetPart = svlib.GetClosestVisiblePlayer()
    if targetPart then
        svlib.AimAtTarget(targetPart)
    end
end

----------------------------------
-- Core Loop Function
----------------------------------

-- Run the main loop
function svlib.RunLoop()
    spawn(function()
        while wait(0.016) do -- ~60fps
            if svlib.Config.ESP.Enabled then
                svlib.UpdateESP()
            end
            
            if svlib.Config.Aimbot.Enabled then
                svlib.UpdateAimbot()
            end
        end
    end)
end

-- Initialize the library
function svlib.Init()
    print("Severe Library initialized!")
    svlib.UpdateScreenSize()
    svlib.RunLoop()
    return svlib
end

-- Return the library
return svlib 
