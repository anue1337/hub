--[[
    Severe Library - An optimized utility library for Severe
    
    Features:
    - Optimized ESP functionality
    - Game object utilities
    - Mouse/input helpers
    - Distance calculations
    - Drawing utilities
]]

-- Initialize library
if not _G.svlib then
    _G.svlib = {
        -- Configuration
        Config = {
            ESP = {
                Enabled = false,
                BoxColor = {255, 255, 255},
                HealthbarEnabled = true,
                NametagEnabled = true,
                DistanceEnabled = true,
                TracerEnabled = false,
                TracerOrigin = "Bottom", -- "Bottom", "Top", "Mouse"
                BoxType = "Corners", -- "Corners", "2D", "3D"
            },
            Aimbot = {
                Enabled = false,
                Smoothness = 0.5,
                FOV = 100,
                TargetPart = "Head",
            },
            Colors = {
                Primary = {255, 255, 255},
                Secondary = {25, 25, 25},
                Accent = {255, 0, 0},
                Background = {15, 15, 15},
                Warning = {255, 200, 0},
                Error = {255, 50, 50},
                Success = {0, 255, 50},
            },
            Performance = {
                MaxESPDistance = 1000,
                MaxDrawObjects = 200,
                UpdateRate = 0.05, -- 20 FPS default
                StableMode = true, -- Novo modo estável que evita criação/destruição excessiva de objetos
                EnableAntiCrash = true,
            },
        },
        
        -- Cache for optimization
        Cache = {
            PlayerData = {},
            DrawingObjects = {},
            ESPObjects = {}, -- ESP objects organized by player name
            UpdateInProgress = false,
            ThreadActive = false,
            LocalPlayer = nil,
            Camera = nil,
            ScreenSize = {x = 0, y = 0},
            DebugMode = true, -- Ativar depuração por padrão
        },
        
        -- Stats for debugging
        Stats = {
            FrameTime = 0,
            ObjectsDrawn = 0,
            LastUpdate = 0,
            FPS = 0,
        },
    }
end

-- Reference to the library
local svlib = _G.svlib

-- Shorthand to Game
local Game = Game

----------------------------------
-- Utility Functions
----------------------------------

-- Debug function
function svlib.Debug(message)
    if svlib.Cache.DebugMode then
        print("[SEVERE LIB DEBUG] " .. message)
    end
end

-- Get screen dimensions
function svlib.UpdateScreenSize()
    local dims = getscreendimensions()
    svlib.Cache.ScreenSize = {x = dims.x, y = dims.y}
    return svlib.Cache.ScreenSize
end

-- Check if mouse is in an area
function svlib.IsMouseInArea(x1, y1, x2, y2)
    local mouse = getmouseposition()
    return (mouse.x >= x1 and mouse.x <= x2 and mouse.y >= y1 and mouse.y <= y2)
end

-- Get distance between two positions
function svlib.GetDistance(pos1, pos2)
    local x = pos1.x - pos2.x
    local y = pos1.y - pos2.y
    local z = pos1.z - pos2.z
    return math.sqrt(x*x + y*y + z*z)
end

-- Get distance from position to player
function svlib.GetDistanceFromPlayer(pos)
    local character = getcharacter(getlocalplayer())
    if not character then return 0 end
    
    local rootPart = findfirstchild(character, "HumanoidRootPart")
    if not rootPart then return 0 end
    
    local playerPos = getposition(rootPart)
    return svlib.GetDistance(playerPos, pos)
end

-- Get game service
function svlib.GetService(serviceName)
    return findservice(Game, serviceName)
end

-- Navigate Game path easily
function svlib.Game(...)
    local current = Game
    local args = {...}
    
    for _, path in ipairs(args) do
        current = findfirstchild(current, path)
        if not current then return nil end
    end
    
    return current
end

----------------------------------
-- Player Functions
----------------------------------

-- Get local player
function svlib.GetLocalPlayer()
    if not svlib.Cache.LocalPlayer then
        svlib.Cache.LocalPlayer = getlocalplayer()
    end
    return svlib.Cache.LocalPlayer
end

-- Get all players
function svlib.GetPlayers()
    local players = svlib.GetService("Players")
    return getchildren(players)
end

-- Get humanoid health
function svlib.GetHealth(humanoid)
    local success, health = pcall(function() return gethealth(humanoid) end)
    local successMax, maxHealth = pcall(function() return getmaxhealth(humanoid) end)
    
    if not success or not successMax then
        return { Health = 100, MaxHealth = 100 }
    end
    
    return {
        Health = health,
        MaxHealth = maxHealth
    }
end

----------------------------------
-- Drawing Functions - Simplificado
----------------------------------

-- Cria ou obtém um objeto de desenho
function svlib.DrawingObject(drawingType, properties)
    local obj = Drawing.new(drawingType)
    
    -- Aplicar propriedades
    for prop, value in pairs(properties or {}) do
        pcall(function() obj[prop] = value end)
    end
    
    -- Adicionar ao cache
    table.insert(svlib.Cache.DrawingObjects, obj)
    
    return obj
end

-- Limpar todos os objetos de desenho
function svlib.ClearAllDrawings()
    for _, obj in ipairs(svlib.Cache.DrawingObjects) do
        pcall(function() 
            if obj and obj.Remove then
                obj:Remove()
            end
        end)
    end
    
    svlib.Cache.DrawingObjects = {}
    svlib.Cache.ESPObjects = {}
    svlib.Debug("Todos os objetos de desenho foram limpos")
end

----------------------------------
-- ESP Functions - Reimplementado
----------------------------------

-- Criar objeto ESP para um personagem
function svlib.CreatePlayerESP(player)
    if not player then return nil end
    
    -- Ignorar jogador local
    local localPlayer = svlib.GetLocalPlayer()
    if player == localPlayer then return nil end
    
    -- Verificar se já existe ESP para este jogador
    local playerName = getname(player)
    if svlib.Cache.ESPObjects[playerName] then
        return svlib.Cache.ESPObjects[playerName]
    end
    
    -- Obter personagem
    local character = nil
    pcall(function() character = getcharacter(player) end)
    if not character then return nil end
    
    -- Verificar partes importantes
    local humanoid = findfirstchildofclass(character, "Humanoid")
    local rootPart = findfirstchild(character, "HumanoidRootPart")
    local head = findfirstchild(character, "Head")
    
    if not humanoid or not rootPart or not head then
        svlib.Debug("Partes importantes não encontradas para " .. playerName)
        return nil
    end
    
    -- Verificar distância
    local characterPos = getposition(rootPart)
    local distance = svlib.GetDistanceFromPlayer(characterPos)
    
    if distance > svlib.Config.Performance.MaxESPDistance then
        return nil
    end
    
    -- Obter posições na tela
    local headPos = getposition(head)
    local rootPos = getposition(rootPart)
    
    -- Converter para coordenadas de tela
    local topScreenPos, topVisible = worldtoscreenpoint({headPos.x, headPos.y + 2, headPos.z})
    local bottomScreenPos, bottomVisible = worldtoscreenpoint({rootPos.x, rootPos.y - 3, rootPos.z})
    
    if not topVisible or not bottomVisible then
        return nil
    end
    
    -- Criar objetos ESP
    local espObjects = {
        BoxLines = {},
        Healthbar = nil,
        NameText = nil,
        DistanceText = nil,
        TracerLine = nil,
        Character = character,
        LastUpdate = time()
    }
    
    -- Dimensões da caixa
    local height = math.max(10, bottomScreenPos.y - topScreenPos.y)
    local width = height / 2
    
    -- Box
    if svlib.Config.ESP.BoxType == "Corners" then
        -- Top left corner
        table.insert(espObjects.BoxLines, svlib.DrawingObject("Line", {
            From = {topScreenPos.x - width/2, topScreenPos.y},
            To = {topScreenPos.x - width/2 + width/4, topScreenPos.y},
            Color = svlib.Config.ESP.BoxColor,
            Thickness = 1,
            Visible = true
        }))
        
        table.insert(espObjects.BoxLines, svlib.DrawingObject("Line", {
            From = {topScreenPos.x - width/2, topScreenPos.y},
            To = {topScreenPos.x - width/2, topScreenPos.y + height/4},
            Color = svlib.Config.ESP.BoxColor,
            Thickness = 1,
            Visible = true
        }))
        
        -- Top right corner
        table.insert(espObjects.BoxLines, svlib.DrawingObject("Line", {
            From = {topScreenPos.x + width/2, topScreenPos.y},
            To = {topScreenPos.x + width/2 - width/4, topScreenPos.y},
            Color = svlib.Config.ESP.BoxColor,
            Thickness = 1,
            Visible = true
        }))
        
        table.insert(espObjects.BoxLines, svlib.DrawingObject("Line", {
            From = {topScreenPos.x + width/2, topScreenPos.y},
            To = {topScreenPos.x + width/2, topScreenPos.y + height/4},
            Color = svlib.Config.ESP.BoxColor,
            Thickness = 1,
            Visible = true
        }))
        
        -- Bottom left corner
        table.insert(espObjects.BoxLines, svlib.DrawingObject("Line", {
            From = {bottomScreenPos.x - width/2, bottomScreenPos.y},
            To = {bottomScreenPos.x - width/2 + width/4, bottomScreenPos.y},
            Color = svlib.Config.ESP.BoxColor,
            Thickness = 1,
            Visible = true
        }))
        
        table.insert(espObjects.BoxLines, svlib.DrawingObject("Line", {
            From = {bottomScreenPos.x - width/2, bottomScreenPos.y},
            To = {bottomScreenPos.x - width/2, bottomScreenPos.y - height/4},
            Color = svlib.Config.ESP.BoxColor,
            Thickness = 1,
            Visible = true
        }))
        
        -- Bottom right corner
        table.insert(espObjects.BoxLines, svlib.DrawingObject("Line", {
            From = {bottomScreenPos.x + width/2, bottomScreenPos.y},
            To = {bottomScreenPos.x + width/2 - width/4, bottomScreenPos.y},
            Color = svlib.Config.ESP.BoxColor,
            Thickness = 1,
            Visible = true
        }))
        
        table.insert(espObjects.BoxLines, svlib.DrawingObject("Line", {
            From = {bottomScreenPos.x + width/2, bottomScreenPos.y},
            To = {bottomScreenPos.x + width/2, bottomScreenPos.y - height/4},
            Color = svlib.Config.ESP.BoxColor,
            Thickness = 1,
            Visible = true
        }))
    elseif svlib.Config.ESP.BoxType == "2D" then
        -- Box completa
        espObjects.BoxLines = svlib.DrawingObject("Square", {
            Position = {topScreenPos.x - width/2, topScreenPos.y},
            Size = {width, height},
            Color = svlib.Config.ESP.BoxColor,
            Thickness = 1,
            Filled = false,
            Visible = true
        })
    end
    
    -- Healthbar
    if svlib.Config.ESP.HealthbarEnabled then
        local healthData = svlib.GetHealth(humanoid)
        local healthRatio = math.min(1, healthData.Health / healthData.MaxHealth)
        
        -- Background
        espObjects.HealthbarBG = svlib.DrawingObject("Square", {
            Position = {topScreenPos.x - width/2 - 5, topScreenPos.y},
            Size = {3, height},
            Color = {0, 0, 0},
            Filled = true,
            Visible = true
        })
        
        -- Fill
        espObjects.Healthbar = svlib.DrawingObject("Square", {
            Position = {topScreenPos.x - width/2 - 5, topScreenPos.y + height * (1 - healthRatio)},
            Size = {3, height * healthRatio},
            Color = {255 * (1 - healthRatio), 255 * healthRatio, 0},
            Filled = true,
            Visible = true
        })
    end
    
    -- Name
    if svlib.Config.ESP.NametagEnabled then
        espObjects.NameText = svlib.DrawingObject("Text", {
            Text = playerName,
            Position = {topScreenPos.x, topScreenPos.y - 20},
            Color = svlib.Config.ESP.BoxColor,
            Size = 13,
            Center = true,
            Outline = true,
            OutlineColor = {0, 0, 0},
            Visible = true
        })
    end
    
    -- Distance
    if svlib.Config.ESP.DistanceEnabled then
        espObjects.DistanceText = svlib.DrawingObject("Text", {
            Text = tostring(math.floor(distance)),
            Position = {bottomScreenPos.x, bottomScreenPos.y + 5},
            Color = svlib.Config.ESP.BoxColor,
            Size = 13,
            Center = true,
            Outline = true,
            OutlineColor = {0, 0, 0},
            Visible = true
        })
    end
    
    -- Tracer
    if svlib.Config.ESP.TracerEnabled then
        local tracerStart = {x = svlib.Cache.ScreenSize.x / 2, y = svlib.Cache.ScreenSize.y}
        
        if svlib.Config.ESP.TracerOrigin == "Top" then
            tracerStart.y = 0
        elseif svlib.Config.ESP.TracerOrigin == "Mouse" then
            local mouse = getmouseposition()
            tracerStart.x = mouse.x
            tracerStart.y = mouse.y
        end
        
        espObjects.TracerLine = svlib.DrawingObject("Line", {
            From = {tracerStart.x, tracerStart.y},
            To = {bottomScreenPos.x, bottomScreenPos.y},
            Color = svlib.Config.ESP.BoxColor,
            Thickness = 1,
            Visible = true
        })
    end
    
    -- Armazenar objetos ESP por nome do jogador
    svlib.Cache.ESPObjects[playerName] = espObjects
    
    return espObjects
end

-- Atualizar ESP para um jogador
function svlib.UpdatePlayerESP(player)
    if not player then return false end
    
    -- Ignorar jogador local
    local localPlayer = svlib.GetLocalPlayer()
    if player == localPlayer then return false end
    
    -- Verificar se existe ESP para este jogador
    local playerName = getname(player)
    local espObjects = svlib.Cache.ESPObjects[playerName]
    
    -- Se não existe, criar novo
    if not espObjects then
        svlib.CreatePlayerESP(player)
        return true
    end
    
    -- Verificar se o personagem ainda é válido
    local character = nil
    pcall(function() character = getcharacter(player) end)
    
    if not character or character ~= espObjects.Character then
        -- Personagem mudou ou não é mais válido, remover ESP antigo
        svlib.RemovePlayerESP(playerName)
        
        -- Tentar criar novo se o personagem for válido
        if character then
            svlib.CreatePlayerESP(player)
        end
        
        return true
    end
    
    -- Verificar partes importantes
    local humanoid = findfirstchildofclass(character, "Humanoid")
    local rootPart = findfirstchild(character, "HumanoidRootPart")
    local head = findfirstchild(character, "Head")
    
    if not humanoid or not rootPart or not head then
        svlib.RemovePlayerESP(playerName)
        return false
    end
    
    -- Verificar distância
    local characterPos = getposition(rootPart)
    local distance = svlib.GetDistanceFromPlayer(characterPos)
    
    if distance > svlib.Config.Performance.MaxESPDistance then
        -- Ocultar ESP ao invés de remover (para evitar piscadas)
        svlib.SetPlayerESPVisible(playerName, false)
        return true
    else {
        -- Mostrar ESP se estava oculto
        svlib.SetPlayerESPVisible(playerName, true)
    }
    
    -- Obter posições na tela
    local headPos = getposition(head)
    local rootPos = getposition(rootPart)
    
    -- Converter para coordenadas de tela
    local topScreenPos, topVisible = worldtoscreenpoint({headPos.x, headPos.y + 2, headPos.z})
    local bottomScreenPos, bottomVisible = worldtoscreenpoint({rootPos.x, rootPos.y - 3, rootPos.z})
    
    if not topVisible or not bottomVisible then
        -- Ocultar ESP ao invés de remover (para evitar piscadas)
        svlib.SetPlayerESPVisible(playerName, false)
        return true
    } else {
        -- Mostrar ESP se estava oculto
        svlib.SetPlayerESPVisible(playerName, true)
    }
    
    -- Dimensões da caixa
    local height = math.max(10, bottomScreenPos.y - topScreenPos.y)
    local width = height / 2
    
    -- Atualizar linhas da caixa
    if svlib.Config.ESP.BoxType == "Corners" then
        if type(espObjects.BoxLines) == "table" and #espObjects.BoxLines >= 8 then
            -- Top left corner
            pcall(function()
                espObjects.BoxLines[1].From = {topScreenPos.x - width/2, topScreenPos.y}
                espObjects.BoxLines[1].To = {topScreenPos.x - width/2 + width/4, topScreenPos.y}
                
                espObjects.BoxLines[2].From = {topScreenPos.x - width/2, topScreenPos.y}
                espObjects.BoxLines[2].To = {topScreenPos.x - width/2, topScreenPos.y + height/4}
                
                -- Top right corner
                espObjects.BoxLines[3].From = {topScreenPos.x + width/2, topScreenPos.y}
                espObjects.BoxLines[3].To = {topScreenPos.x + width/2 - width/4, topScreenPos.y}
                
                espObjects.BoxLines[4].From = {topScreenPos.x + width/2, topScreenPos.y}
                espObjects.BoxLines[4].To = {topScreenPos.x + width/2, topScreenPos.y + height/4}
                
                -- Bottom left corner
                espObjects.BoxLines[5].From = {bottomScreenPos.x - width/2, bottomScreenPos.y}
                espObjects.BoxLines[5].To = {bottomScreenPos.x - width/2 + width/4, bottomScreenPos.y}
                
                espObjects.BoxLines[6].From = {bottomScreenPos.x - width/2, bottomScreenPos.y}
                espObjects.BoxLines[6].To = {bottomScreenPos.x - width/2, bottomScreenPos.y - height/4}
                
                -- Bottom right corner
                espObjects.BoxLines[7].From = {bottomScreenPos.x + width/2, bottomScreenPos.y}
                espObjects.BoxLines[7].To = {bottomScreenPos.x + width/2 - width/4, bottomScreenPos.y}
                
                espObjects.BoxLines[8].From = {bottomScreenPos.x + width/2, bottomScreenPos.y}
                espObjects.BoxLines[8].To = {bottomScreenPos.x + width/2, bottomScreenPos.y - height/4}
            end)
        end
    elseif svlib.Config.ESP.BoxType == "2D" then
        pcall(function()
            espObjects.BoxLines.Position = {topScreenPos.x - width/2, topScreenPos.y}
            espObjects.BoxLines.Size = {width, height}
        end)
    end
    
    -- Atualizar barra de vida
    if svlib.Config.ESP.HealthbarEnabled and espObjects.Healthbar and espObjects.HealthbarBG then
        local healthData = svlib.GetHealth(humanoid)
        local healthRatio = math.min(1, healthData.Health / healthData.MaxHealth)
        
        pcall(function()
            espObjects.HealthbarBG.Position = {topScreenPos.x - width/2 - 5, topScreenPos.y}
            espObjects.HealthbarBG.Size = {3, height}
            
            espObjects.Healthbar.Position = {topScreenPos.x - width/2 - 5, topScreenPos.y + height * (1 - healthRatio)}
            espObjects.Healthbar.Size = {3, height * healthRatio}
            espObjects.Healthbar.Color = {255 * (1 - healthRatio), 255 * healthRatio, 0}
        end)
    end
    
    -- Atualizar nome
    if svlib.Config.ESP.NametagEnabled and espObjects.NameText then
        pcall(function()
            espObjects.NameText.Position = {topScreenPos.x, topScreenPos.y - 20}
        end)
    end
    
    -- Atualizar distância
    if svlib.Config.ESP.DistanceEnabled and espObjects.DistanceText then
        pcall(function()
            espObjects.DistanceText.Text = tostring(math.floor(distance))
            espObjects.DistanceText.Position = {bottomScreenPos.x, bottomScreenPos.y + 5}
        end)
    end
    
    -- Atualizar traçador
    if svlib.Config.ESP.TracerEnabled and espObjects.TracerLine then
        local tracerStart = {x = svlib.Cache.ScreenSize.x / 2, y = svlib.Cache.ScreenSize.y}
        
        if svlib.Config.ESP.TracerOrigin == "Top" then
            tracerStart.y = 0
        elseif svlib.Config.ESP.TracerOrigin == "Mouse" then
            local mouse = getmouseposition()
            tracerStart.x = mouse.x
            tracerStart.y = mouse.y
        end
        
        pcall(function()
            espObjects.TracerLine.From = {tracerStart.x, tracerStart.y}
            espObjects.TracerLine.To = {bottomScreenPos.x, bottomScreenPos.y}
        end)
    end
    
    -- Atualizar timestamp
    espObjects.LastUpdate = time()
    
    return true
end

-- Definir visibilidade do ESP de um jogador
function svlib.SetPlayerESPVisible(playerName, visible)
    local espObjects = svlib.Cache.ESPObjects[playerName]
    if not espObjects then return end
    
    -- Atualizar visibilidade de todos os componentes
    local function updateVisibility(obj)
        if obj and type(obj) == "table" then
            if obj.Visible ~= nil then
                pcall(function() obj.Visible = visible end)
            else
                for _, subObj in pairs(obj) do
                    if subObj and subObj.Visible ~= nil then
                        pcall(function() subObj.Visible = visible end)
                    end
                end
            end
        end
    end
    
    updateVisibility(espObjects.BoxLines)
    updateVisibility(espObjects.Healthbar)
    updateVisibility(espObjects.HealthbarBG)
    updateVisibility(espObjects.NameText)
    updateVisibility(espObjects.DistanceText)
    updateVisibility(espObjects.TracerLine)
end

-- Remover ESP de um jogador
function svlib.RemovePlayerESP(playerName)
    local espObjects = svlib.Cache.ESPObjects[playerName]
    if not espObjects then return end
    
    -- Remover todos os objetos de desenho
    local function removeObject(obj)
        if obj and type(obj) == "table" then
            if obj.Remove then
                pcall(function() obj:Remove() end)
                
                -- Remover da lista de objetos
                for i, drawObj in ipairs(svlib.Cache.DrawingObjects) do
                    if drawObj == obj then
                        table.remove(svlib.Cache.DrawingObjects, i)
                        break
                    end
                end
            else
                for _, subObj in pairs(obj) do
                    if subObj and subObj.Remove then
                        pcall(function() subObj:Remove() end)
                        
                        -- Remover da lista de objetos
                        for i, drawObj in ipairs(svlib.Cache.DrawingObjects) do
                            if drawObj == subObj then
                                table.remove(svlib.Cache.DrawingObjects, i)
                                break
                            end
                        end
                    end
                end
            end
        end
    end
    
    removeObject(espObjects.BoxLines)
    removeObject(espObjects.Healthbar)
    removeObject(espObjects.HealthbarBG)
    removeObject(espObjects.NameText)
    removeObject(espObjects.DistanceText)
    removeObject(espObjects.TracerLine)
    
    -- Remover da lista de ESPs
    svlib.Cache.ESPObjects[playerName] = nil
end

-- Atualizar todos os ESPs
function svlib.UpdateAllESPs()
    if svlib.Cache.UpdateInProgress then return end
    svlib.Cache.UpdateInProgress = true
    
    local localPlayer = svlib.GetLocalPlayer()
    if not localPlayer then 
        svlib.Cache.UpdateInProgress = false
        return 
    end
    
    -- Atualizar dimensões da tela
    svlib.UpdateScreenSize()
    
    -- Obter todos os jogadores
    local players = svlib.GetPlayers()
    local playerNames = {}
    
    -- Processar cada jogador
    for _, player in ipairs(players) do
        if player ~= localPlayer then
            local playerName = nil
            pcall(function() playerName = getname(player) end)
            
            if playerName then
                -- Salvar nome para verificação posterior
                table.insert(playerNames, playerName)
                
                -- Atualizar ESP para este jogador
                svlib.UpdatePlayerESP(player)
            end
        end
    end
    
    -- Verificar jogadores que foram removidos do jogo
    for playerName in pairs(svlib.Cache.ESPObjects) do
        local found = false
        for _, name in ipairs(playerNames) do
            if name == playerName then
                found = true
                break
            end
        end
        
        if not found then
            svlib.RemovePlayerESP(playerName)
        end
    end
    
    -- Atualizar estatísticas
    svlib.Stats.ObjectsDrawn = #svlib.Cache.DrawingObjects
    svlib.Stats.FrameTime = time() - svlib.Stats.LastUpdate
    svlib.Stats.LastUpdate = time()
    svlib.Stats.FPS = svlib.Stats.FrameTime > 0 and math.floor(1 / svlib.Stats.FrameTime) or 0
    
    svlib.Cache.UpdateInProgress = false
end

----------------------------------
-- Aimbot Functions
----------------------------------

-- Get closest visible player
function svlib.GetClosestVisiblePlayer()
    local localPlayer = svlib.GetLocalPlayer()
    local localCharacter = getcharacter(localPlayer)
    if not localCharacter then return nil end
    
    local localHead = findfirstchild(localCharacter, "Head")
    if not localHead then return nil end
    
    local localHeadPos = getposition(localHead)
    local closestDistance = math.huge
    local targetPlayer = nil
    local targetPart = nil
    
    for _, player in ipairs(svlib.GetPlayers()) do
        if player ~= localPlayer then
            local character = getcharacter(player)
            if character then
                local humanoid = findfirstchildofclass(character, "Humanoid")
                if humanoid and gethealth(humanoid) > 0 then
                    local part = findfirstchild(character, svlib.Config.Aimbot.TargetPart)
                    if part then
                        local partPos = getposition(part)
                        local distance = svlib.GetDistance(localHeadPos, partPos)
                        
                        if distance < closestDistance and distance <= svlib.Config.Aimbot.FOV then
                            -- Check if target is visible
                            local screenPos, visible = worldtoscreenpoint({partPos.x, partPos.y, partPos.z})
                            if visible then
                                closestDistance = distance
                                targetPlayer = player
                                targetPart = part
                            end
                        end
                    end
                end
            end
        end
    end
    
    return targetPlayer, targetPart
end

-- Aim at target
function svlib.AimAtTarget(targetPart)
    if not targetPart then return end
    
    local targetPos = getposition(targetPart)
    local screenPos, visible = worldtoscreenpoint({targetPos.x, targetPos.y, targetPos.z})
    
    if visible then
        local mousePos = getmouseposition()
        local aimPos = {screenPos.x, screenPos.y}
        
        -- Apply smooth aim
        local result = smoothmouse_linear({mousePos.x, mousePos.y}, aimPos, 1, svlib.Config.Aimbot.Smoothness)
        mousemoverel(result.x, result.y)
    end
end

-- Aimbot update function
function svlib.UpdateAimbot()
    if not svlib.Config.Aimbot.Enabled then return end
    
    local _, targetPart = svlib.GetClosestVisiblePlayer()
    if targetPart then
        svlib.AimAtTarget(targetPart)
    end
end

----------------------------------
-- Core Functions - Simplificado
----------------------------------

-- Run main loop
function svlib.RunMainLoop()
    -- Parar loop anterior se existir
    svlib.StopMainLoop()
    wait(0.1) -- Pequena pausa para garantir que thread anterior parou
    
    print("Iniciando loop principal")
    svlib.Cache.ThreadActive = true
    
    -- Thread principal - usar pcall para evitar quebras
    spawn(function()
        while svlib.Cache.ThreadActive do
            pcall(function()
                if svlib.Config.ESP.Enabled then
                    svlib.UpdateAllESPs()
                end
                
                if svlib.Config.Aimbot.Enabled then
                    svlib.UpdateAimbot()
                end
            end)
            
            -- Use taxa de atualização estável
            wait(svlib.Config.Performance.UpdateRate)
        end
    end)
    
    -- Thread de monitoramento para garantir que ESP continue funcionando
    spawn(function()
        while svlib.Cache.ThreadActive do
            wait(3) -- Verificar a cada 3 segundos
            
            -- Se o ESP está habilitado mas não há objetos desenhados, tentar reiniciar
            if svlib.Config.ESP.Enabled and svlib.Stats.ObjectsDrawn == 0 then
                print("ESP parece estar sem objetos! Tentando reiniciar...")
                
                -- Forçar recriação dos objetos ESP
                svlib.ClearAllDrawings()
                
                -- Garantir que ESP esteja habilitado
                svlib.Config.ESP.Enabled = true
            end
        end
    end)
end

-- Stop main loop
function svlib.StopMainLoop()
    print("Parando loop principal...")
    svlib.Cache.ThreadActive = false
end

-- Initialize the library
function svlib.Init()
    print("Inicializando Severe Library")
    
    -- Reset de configurações para garantir funcionamento
    svlib.Config.Performance.UpdateRate = 0.05
    svlib.Config.Performance.EnableAntiCrash = true
    
    -- Limpar desenhos existentes
    svlib.ClearAllDrawings()
    
    -- Atualizar tamanho da tela
    svlib.UpdateScreenSize()
    
    -- Iniciar loop principal
    svlib.RunMainLoop()
    
    return svlib
end

-- Return the library
return svlib 
