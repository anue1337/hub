--[[
    Anue UI Library for Severe
]]

-- Theme System
local Theme = {
    Background = {25, 25, 25},
    Accent = {0, 190, 255},
    Text = {255, 255, 255},
    Border = {50, 50, 50},
    ButtonIdle = {35, 35, 35},
    ButtonHover = {45, 45, 45},
    CheckboxBorder = {80, 80, 80},
    SliderBg = {40, 40, 40},
    TabActive = {35, 35, 35},
    TabInactive = {30, 30, 30},
    DefaultFont = 2
}

-- UIManager (Central update system)
local UIManager = {
    Elements = {},
    Windows = {},
    Running = true,
    MousePosition = {x = 0, y = 0},
    MouseLeftClicked = false,
    MouseLeftPressed = false,
    PreviousLeftClicked = false,
    HoveredElement = nil,
    ActiveElement = nil,
    LastFrameTime = 0,
    DeltaTime = 0
}

function UIManager:Initialize()
    -- Start the update loop
    spawn(function()
        while self.Running do
            self:Update()
            wait(0.01) -- Small delay to prevent excessive CPU usage
        end
    end)
    
    return self
end

function UIManager:Update()
    -- Calculate delta time
    local currentTime = tick()
    self.DeltaTime = currentTime - self.LastFrameTime
    self.LastFrameTime = currentTime
    
    -- Update mouse state
    local mousePos = getmouseposition()
    self.MousePosition = mousePos
    self.PreviousLeftClicked = self.MouseLeftClicked
    self.MouseLeftClicked = isleftclicked()
    self.MouseLeftPressed = isleftpressed()
    
    -- Handle window updates first (since they contain tabs and elements)
    for _, window in ipairs(self.Windows) do
        if window.Visible then
            self:ProcessWindow(window)
        end
    end
    
    -- Handle individual elements not in windows
    for _, element in ipairs(self.Elements) do
        if element.Visible then
            self:ProcessElement(element)
        end
    end
end

function UIManager:ProcessWindow(window)
    -- Check for window dragging
    if window.Dragging then
        if self.MouseLeftPressed then
            local newX = self.MousePosition.x - window.DragOffset[1]
            local newY = self.MousePosition.y - window.DragOffset[2]
            window:SetPosition({newX, newY})
        else
            window.Dragging = false
        end
    else
        -- Check if starting a drag operation
        local isInHeader = self:IsPointInRect(
            self.MousePosition.x, self.MousePosition.y,
            window.Position[1], window.Position[2],
            window.Size[1], window.HeaderHeight
        )
        
        if isInHeader and self.MouseLeftClicked and not self.PreviousLeftClicked then
            window.Dragging = true
            window.DragOffset = {
                self.MousePosition.x - window.Position[1],
                self.MousePosition.y - window.Position[2]
            }
        end
    end
    
    -- Check tab interactions if window has tabs
    if #window.Tabs > 0 then
        for _, tab in ipairs(window.Tabs) do
            local isInTabButton = self:IsPointInRect(
                self.MousePosition.x, self.MousePosition.y,
                tab.ButtonPosition[1], tab.ButtonPosition[2],
                tab.ButtonSize[1], tab.ButtonSize[2]
            )
            
            if isInTabButton and self.MouseLeftClicked and not self.PreviousLeftClicked then
                window:SelectTab(tab.Name)
            end
        end
    end
    
    -- Process active tab elements or direct window elements
    if window.ActiveTab then
        for _, element in ipairs(window.ActiveTab.Children) do
            if element.Visible then
                self:ProcessElement(element)
            end
        end
    end
    
    -- Process direct window elements
    for _, element in ipairs(window.Children) do
        if element.Visible then
            self:ProcessElement(element)
        end
    end
end

function UIManager:ProcessElement(element)
    -- Handle different element types
    if element.Type == "Button" then
        self:ProcessButton(element)
    elseif element.Type == "Checkbox" then
        self:ProcessCheckbox(element)
    elseif element.Type == "Slider" then
        self:ProcessSlider(element)
    end
    -- Add more element types as needed
end

function UIManager:ProcessButton(button)
    local isHovered = self:IsPointInRect(
        self.MousePosition.x, self.MousePosition.y,
        button.Position[1], button.Position[2],
        button.Size[1], button.Size[2]
    )
    
    local oldState = button.State
    
    if isHovered then
        if self.MouseLeftPressed then
            button.State = "Pressed"
        else
            button.State = "Hover"
            
            -- Check for click completion (release while hovering)
            if oldState == "Pressed" and not self.MouseLeftPressed and self.PreviousLeftClicked then
                spawn(function() 
                    button.Callback() 
                end)
            end
        end
    else
        button.State = "Idle"
    end
    
    -- Re-render if state changed
    if oldState ~= button.State then
        button:Render()
    end
end

function UIManager:ProcessCheckbox(checkbox)
    -- Define the clickable area (includes both checkbox and label)
    local labelWidth = checkbox.TextObj and checkbox.TextObj.TextBounds and checkbox.TextObj.TextBounds.x or 100
    local clickableWidth = checkbox.Size + 5 + labelWidth
    
    local isHovered = self:IsPointInRect(
        self.MousePosition.x, self.MousePosition.y,
        checkbox.Position[1], checkbox.Position[2],
        clickableWidth, checkbox.Size
    )
    
    -- Handle click
    if isHovered and self.MouseLeftClicked and not self.PreviousLeftClicked then
        checkbox.Value = not checkbox.Value
        checkbox:Render()
        
        -- Call the callback
        spawn(function() 
            checkbox.OnToggle(checkbox.Value) 
        end)
    end
end

function UIManager:ProcessSlider(slider)
    -- Define the clickable areas
    local sliderArea = {
        x1 = slider.Position[1] - 5,
        y1 = slider.Position[2] - 5,
        x2 = slider.Position[1] + slider.Size[1] + 5,
        y2 = slider.Position[2] + slider.Size[2] + 5
    }
    
    local handleArea = {
        x1 = slider.Handle.Position.x - 2,
        y1 = slider.Handle.Position.y - 2,
        x2 = slider.Handle.Position.x + slider.Handle.Size.x + 2,
        y2 = slider.Handle.Position.y + slider.Handle.Size.y + 2
    }
    
    local isInHandleArea = self:IsPointInRect(
        self.MousePosition.x, self.MousePosition.y,
        handleArea.x1, handleArea.y1,
        handleArea.x2 - handleArea.x1, handleArea.y2 - handleArea.y1
    )
    
    local isInSliderArea = self:IsPointInRect(
        self.MousePosition.x, self.MousePosition.y,
        sliderArea.x1, sliderArea.y1,
        sliderArea.x2 - sliderArea.x1, sliderArea.y2 - sliderArea.y1
    )
    
    -- Start dragging on click
    if self.MouseLeftClicked and not self.PreviousLeftClicked and (isInHandleArea or isInSliderArea) then
        slider.Dragging = true
    end
    
    -- Handle dragging
    if slider.Dragging then
        if self.MouseLeftPressed then
            -- Calculate new value based on mouse position
            local clampedX = math.clamp(self.MousePosition.x, slider.Position[1], slider.Position[1] + slider.Size[1])
            local percentage = (clampedX - slider.Position[1]) / slider.Size[1]
            local rawValue = slider.Min + percentage * (slider.Max - slider.Min)
            
            -- Apply step increments
            local steps = math.floor((rawValue - slider.Min) / slider.Step + 0.5)
            local newValue = slider.Min + steps * slider.Step
            
            -- Only update if value changed
            if newValue ~= slider.Value then
                slider.Value = newValue
                slider:Render()
                
                -- Call the callback
                spawn(function() 
                    slider.OnChange(slider.Value) 
                end)
            end
        else
            slider.Dragging = false
        end
    end
end

function UIManager:IsPointInRect(x, y, rectX, rectY, rectWidth, rectHeight)
    return x >= rectX and x <= rectX + rectWidth and y >= rectY and y <= rectY + rectHeight
end

function UIManager:RegisterElement(element)
    table.insert(self.Elements, element)
    return element
end

function UIManager:RegisterWindow(window)
    table.insert(self.Windows, window)
    return window
end

function UIManager:Destroy()
    self.Running = false
    
    -- Clear all elements
    for _, element in ipairs(self.Elements) do
        if element.Destroy then
            element:Destroy()
        end
    end
    
    -- Clear all windows
    for _, window in ipairs(self.Windows) do
        if window.Destroy then
            window:Destroy()
        end
    end
    
    self.Elements = {}
    self.Windows = {}
end

-- DrawService Module
local DrawService = {}

function DrawService.New(type, props)
    local drawObj = Drawing.new(type)
    if props then
        for prop, value in pairs(props) do
            drawObj[prop] = value
        end
    end
    return drawObj
end

-- Object Base Class
local Object = {}
Object.__index = Object

function Object.new()
    local self = setmetatable({}, Object)
    self.Elements = {}
    self.Visible = true
    return self
end

function Object:AddElement(drawObj)
    table.insert(self.Elements, drawObj)
    return drawObj
end

function Object:SetVisible(state)
    self.Visible = state
    for _, element in ipairs(self.Elements) do
        element.Visible = state
    end
end

function Object:Destroy()
    for _, element in ipairs(self.Elements) do
        if element.Remove then
            element:Remove()
        end
    end
    self.Elements = {}
end

-- Tab Component
local Tab = {}
Tab.__index = Tab
setmetatable(Tab, {__index = Object})

function Tab.new(name, parent)
    local self = setmetatable(Object.new(), Tab)
    
    self.Name = name or "Tab"
    self.Parent = parent
    self.Children = {}
    self.Active = false
    self.Button = nil
    self.ButtonPosition = {0, 0}
    self.ButtonSize = {0, 0}
    
    return self
end

function Tab:AddChild(child)
    table.insert(self.Children, child)
    return child
end

function Tab:SetActive(active)
    self.Active = active
    
    -- Update visual state of tab button
    if self.Button then
        self.Button.Color = active and Theme.TabActive or Theme.TabInactive
        
        -- Show accent indicator for active tab
        if self.AccentIndicator then
            self.AccentIndicator.Visible = active and self.Visible
        end
    end
    
    -- Show/hide all children
    for _, child in ipairs(self.Children) do
        child:SetVisible(active and self.Visible)
    end
end

function Tab:SetVisible(state)
    self.Visible = state
    
    -- Update button visibility
    if self.Button then
        self.Button.Visible = state
    end
    
    if self.TabText then
        self.TabText.Visible = state
    end
    
    if self.AccentIndicator then
        self.AccentIndicator.Visible = state and self.Active
    end
    
    -- Only show children if tab is active
    for _, child in ipairs(self.Children) do
        child:SetVisible(state and self.Active)
    end
end

function Tab:Destroy()
    Object.Destroy(self)
    
    for _, child in ipairs(self.Children) do
        child:Destroy()
    end
    self.Children = {}
end

-- Label Component
local Label = {}
Label.__index = Label
setmetatable(Label, {__index = Object})

function Label.new(text, position, size, color)
    local self = setmetatable(Object.new(), Label)
    
    self.Text = text or ""
    self.Position = position or {0, 0}
    self.Size = size or 13
    self.Color = color or Theme.Text
    self.Type = "Label"
    
    self:Render()
    return self
end

function Label:Render()
    if self.TextObj then
        self.TextObj:Remove()
    end
    
    self.TextObj = self:AddElement(DrawService.New("Text", {
        Text = self.Text,
        Position = self.Position,
        Size = self.Size,
        Color = self.Color,
        Outline = false,
        Font = Theme.DefaultFont,
        Visible = self.Visible
    }))
end

function Label:SetText(text)
    self.Text = text
    if self.TextObj then
        self.TextObj.Text = text
    end
end

function Label:SetPosition(position)
    self.Position = position
    if self.TextObj then
        self.TextObj.Position = position
    end
end

function Label:SetColor(color)
    self.Color = color
    if self.TextObj then
        self.TextObj.Color = color
    end
end

function Label:SetSize(size)
    self.Size = size
    if self.TextObj then
        self.TextObj.Size = size
    end
end

-- Slider Component
local Slider = {}
Slider.__index = Slider
setmetatable(Slider, {__index = Object})

function Slider.new(label, position, size, min, max, default, step, onChange)
    local self = setmetatable(Object.new(), Slider)
    
    self.Label = label or "Slider"
    self.Position = position or {0, 0}
    self.Size = size or {150, 4} -- Width, height
    self.Min = min or 0
    self.Max = max or 100
    self.Step = step or 1
    self.Value = default or self.Min
    self.OnChange = onChange or function() end
    self.Dragging = false
    self.Type = "Slider"
    
    -- Ensure value is within bounds and aligned to step
    self.Value = math.clamp(self.Value, self.Min, self.Max)
    local steps = math.floor((self.Value - self.Min) / self.Step + 0.5)
    self.Value = self.Min + steps * self.Step
    
    self:Render()
    return self
end

function Slider:Render()
    -- Remove old elements if they exist
    for _, element in ipairs(self.Elements) do
        if element.Remove then
            element:Remove()
        end
    end
    self.Elements = {}
    
    -- Calculate handle position based on current value
    local percentage = (self.Value - self.Min) / (self.Max - self.Min)
    local handleX = self.Position[1] + percentage * self.Size[1]
    
    -- Slider label with value
    self.TextObj = self:AddElement(DrawService.New("Text", {
        Text = self.Label .. ": " .. self.Value,
        Position = {self.Position[1], self.Position[2] - 16},
        Size = 13,
        Color = Theme.Text,
        Outline = false,
        Font = Theme.DefaultFont,
        Visible = self.Visible
    }))
    
    -- Slider background line
    self.Background = self:AddElement(DrawService.New("Line", {
        From = {self.Position[1], self.Position[2] + self.Size[2]/2},
        To = {self.Position[1] + self.Size[1], self.Position[2] + self.Size[2]/2},
        Thickness = self.Size[2],
        Color = Theme.SliderBg,
        Transparency = 1,
        Visible = self.Visible
    }))
    
    -- Filled progress line
    if percentage > 0 then
        self.Fill = self:AddElement(DrawService.New("Line", {
            From = {self.Position[1], self.Position[2] + self.Size[2]/2},
            To = {handleX, self.Position[2] + self.Size[2]/2},
            Thickness = self.Size[2],
            Color = Theme.Accent,
            Transparency = 1,
            Visible = self.Visible
        }))
    end
    
    -- Handle
    self.Handle = self:AddElement(DrawService.New("Square", {
        Position = {handleX - 4, self.Position[2] - 2},
        Size = {8, 8},
        Filled = true,
        Color = Theme.Accent,
        Transparency = 1,
        Visible = self.Visible
    }))
end

function Slider:SetPosition(position)
    self.Position = position
    self:Render()
end

function Slider:SetSize(size)
    self.Size = size
    self:Render()
end

function Slider:SetValue(value)
    local newValue = math.clamp(value, self.Min, self.Max)
    local steps = math.floor((newValue - self.Min) / self.Step + 0.5)
    newValue = self.Min + steps * self.Step
    
    if newValue ~= self.Value then
        self.Value = newValue
        self:Render()
        
        -- Call the callback
        spawn(function() 
            self.OnChange(self.Value) 
        end)
    end
end

function Slider:GetValue()
    return self.Value
end

function Slider:SetLabel(label)
    self.Label = label
    self:Render()
end

function Slider:SetCallback(callback)
    self.OnChange = callback or function() end
end

function Slider:SetMinMax(min, max)
    self.Min = min
    self.Max = max
    self:SetValue(self.Value) -- This will clamp the value and re-render
end

function Slider:SetStep(step)
    self.Step = step
    self:SetValue(self.Value) -- This will align to step and re-render
end

-- Checkbox Component
local Checkbox = {}
Checkbox.__index = Checkbox
setmetatable(Checkbox, {__index = Object})

function Checkbox.new(label, position, defaultState, onToggle)
    local self = setmetatable(Object.new(), Checkbox)
    
    self.Label = label or "Checkbox"
    self.Position = position or {0, 0}
    self.Value = defaultState or false
    self.OnToggle = onToggle or function() end
    self.Size = 12 -- Fixed size for checkbox
    self.Type = "Checkbox"
    
    self:Render()
    return self
end

function Checkbox:Render()
    -- Remove old elements if they exist
    for _, element in ipairs(self.Elements) do
        if element.Remove then
            element:Remove()
        end
    end
    self.Elements = {}
    
    -- Checkbox border (outer square)
    self.Border = self:AddElement(DrawService.New("Square", {
        Position = self.Position,
        Size = {self.Size, self.Size},
        Filled = false,
        Color = Theme.CheckboxBorder,
        Transparency = 1,
        Thickness = 1,
        Visible = self.Visible
    }))
    
    -- Checkbox fill (inner square) - only visible when checked
    if self.Value then
        self.Fill = self:AddElement(DrawService.New("Square", {
            Position = {self.Position[1] + 2, self.Position[2] + 2},
            Size = {self.Size - 4, self.Size - 4},
            Filled = true,
            Color = Theme.Accent,
            Transparency = 1,
            Thickness = 0,
            Visible = self.Visible
        }))
    end
    
    -- Label text
    self.TextObj = self:AddElement(DrawService.New("Text", {
        Text = self.Label,
        Position = {self.Position[1] + self.Size + 5, self.Position[2] - 2},
        Size = 13,
        Color = Theme.Text,
        Outline = false,
        Font = Theme.DefaultFont,
        Visible = self.Visible
    }))
end

function Checkbox:SetPosition(position)
    self.Position = position
    self:Render()
end

function Checkbox:SetValue(value)
    if self.Value ~= value then
        self.Value = value
        self:Render()
        
        -- Call the callback
        spawn(function() 
            self.OnToggle(self.Value) 
        end)
    end
end

function Checkbox:GetValue()
    return self.Value
end

function Checkbox:SetLabel(label)
    self.Label = label
    self:Render()
end

function Checkbox:SetCallback(callback)
    self.OnToggle = callback or function() end
end

-- Button Component
local Button = {}
Button.__index = Button
setmetatable(Button, {__index = Object})

function Button.new(text, position, size, callback)
    local self = setmetatable(Object.new(), Button)
    
    self.Text = text or "Button"
    self.Position = position or {0, 0}
    self.Size = size or {100, 25}
    self.Callback = callback or function() end
    self.State = "Idle" -- Idle, Hover, Pressed
    self.Type = "Button"
    
    self:Render()
    return self
end

function Button:Render()
    -- Remove old elements if they exist
    for _, element in ipairs(self.Elements) do
        if element.Remove then
            element:Remove()
        end
    end
    self.Elements = {}
    
    -- Background based on current state
    local bgColor = Theme.ButtonIdle
    if self.State == "Hover" then
        bgColor = Theme.ButtonHover
    elseif self.State == "Pressed" then
        bgColor = Theme.Accent
    end
    
    -- Background
    self.Background = self:AddElement(DrawService.New("Square", {
        Position = self.Position,
        Size = self.Size,
        Filled = true,
        Color = bgColor,
        Transparency = 1,
        Thickness = 0,
        Visible = self.Visible
    }))
    
    -- Text (centered)
    local textX = self.Position[1] + (self.Size[1] / 2)
    local textY = self.Position[2] + (self.Size[2] / 2) - 7 -- Adjust for text centering
    
    self.TextObj = self:AddElement(DrawService.New("Text", {
        Text = self.Text,
        Position = {textX, textY},
        Size = 13,
        Color = Theme.Text,
        Outline = false,
        Center = true,
        Font = Theme.DefaultFont,
        Visible = self.Visible
    }))
end

function Button:SetPosition(position)
    self.Position = position
    self:Render()
end

function Button:SetSize(size)
    self.Size = size
    self:Render()
end

function Button:SetText(text)
    self.Text = text
    if self.TextObj then
        self.TextObj.Text = text
    end
end

function Button:SetCallback(callback)
    self.Callback = callback or function() end
end

-- Window Component (Container)
local Window = {}
Window.__index = Window
setmetatable(Window, {__index = Object})

function Window.new(title, position, size)
    local self = setmetatable(Object.new(), Window)
    
    self.Title = title or "Window"
    self.Position = position or {100, 100}
    self.Size = size or {300, 200}
    self.Dragging = false
    self.DragOffset = {0, 0}
    self.Children = {}
    self.HeaderHeight = 22
    self.Tabs = {}
    self.ActiveTab = nil
    self.TabButtonHeight = 25
    self.ContentY = self.HeaderHeight + self.TabButtonHeight
    self.Type = "Window"
    
    self:Render()
    return self
end

function Window:Render()
    -- Background
    self.Background = self:AddElement(DrawService.New("Square", {
        Position = self.Position,
        Size = self.Size,
        Filled = true,
        Color = Theme.Background,
        Transparency = 1,
        Thickness = 0,
        Visible = self.Visible
    }))
    
    -- Header (title bar)
    self.Header = self:AddElement(DrawService.New("Square", {
        Position = self.Position,
        Size = {self.Size[1], self.HeaderHeight},
        Filled = true,
        Color = Theme.Background,
        Transparency = 1,
        Thickness = 0,
        Visible = self.Visible
    }))
    
    -- Header accent line
    self.HeaderAccent = self:AddElement(DrawService.New("Square", {
        Position = {self.Position[1], self.Position[2] + self.HeaderHeight},
        Size = {self.Size[1], 1},
        Filled = true,
        Color = Theme.Accent,
        Transparency = 1,
        Thickness = 0,
        Visible = self.Visible
    }))
    
    -- Title text
    self.TitleText = self:AddElement(DrawService.New("Text", {
        Text = self.Title,
        Position = {self.Position[1] + 8, self.Position[2] + (self.HeaderHeight/2) - 7},
        Size = 13,
        Color = Theme.Text,
        Outline = false,
        Font = Theme.DefaultFont,
        Visible = self.Visible
    }))
    
    -- Tab buttons area
    self.TabArea = self:AddElement(DrawService.New("Square", {
        Position = {self.Position[1], self.Position[2] + self.HeaderHeight + 1},
        Size = {self.Size[1], self.TabButtonHeight - 1},
        Filled = true,
        Color = Theme.Background,
        Transparency = 1,
        Thickness = 0,
        Visible = self.Visible
    }))
    
    -- Render tab buttons
    self:RenderTabs()
end

function Window:RenderTabs()
    -- Remove old tab buttons
    for _, tab in ipairs(self.Tabs) do
        if tab.Button then
            tab.Button:Remove()
            tab.Button = nil
        end
        if tab.TabText then
            tab.TabText:Remove()
            tab.TabText = nil
        end
        if tab.AccentIndicator then
            tab.AccentIndicator:Remove()
            tab.AccentIndicator = nil
        end
    end
    
    -- Calculate tab button width (divide available width by number of tabs)
    local tabCount = #self.Tabs
    if tabCount == 0 then return end
    
    local tabWidth = self.Size[1] / tabCount
    
    -- Create buttons for each tab
    for i, tab in ipairs(self.Tabs) do
        local tabX = self.Position[1] + (i-1) * tabWidth
        
        -- Store button position and size for interaction detection
        tab.ButtonPosition = {tabX, self.Position[2] + self.HeaderHeight + 1}
        tab.ButtonSize = {tabWidth, self.TabButtonHeight - 1}
        
        -- Tab button background
        tab.Button = DrawService.New("Square", {
            Position = tab.ButtonPosition,
            Size = tab.ButtonSize,
            Filled = true,
            Color = tab.Active and Theme.TabActive or Theme.TabInactive,
            Transparency = 1,
            Thickness = 0,
            Visible = self.Visible
        })
        
        -- Tab text (centered)
        local textX = tabX + (tabWidth / 2)
        local textY = self.Position[2] + self.HeaderHeight + 1 + (self.TabButtonHeight / 2) - 7
        
        tab.TabText = DrawService.New("Text", {
            Text = tab.Name,
            Position = {textX, textY},
            Size = 13,
            Color = Theme.Text,
            Outline = false,
            Center = true,
            Font = Theme.DefaultFont,
            Visible = self.Visible
        })
        
        -- Accent indicator for active tab (thin line at bottom)
        if tab.Active then
            tab.AccentIndicator = DrawService.New("Square", {
                Position = {tabX, self.Position[2] + self.HeaderHeight + self.TabButtonHeight},
                Size = {tabWidth, 1},
                Filled = true,
                Color = Theme.Accent,
                Transparency = 1,
                Thickness = 0,
                Visible = self.Visible
            })
        end
    end
end

function Window:AddTab(name)
    -- Create a new tab
    local tab = Tab.new(name, self)
    table.insert(self.Tabs, tab)
    
    -- If this is the first tab, make it active
    if #self.Tabs == 1 then
        self.ActiveTab = tab
        tab.Active = true
    end
    
    -- Re-render the tabs
    self:RenderTabs()
    
    return tab
end

function Window:SelectTab(name)
    local foundTab = nil
    
    -- Find the tab by name
    for _, tab in ipairs(self.Tabs) do
        if tab.Name == name then
            foundTab = tab
            break
        end
    end
    
    -- If tab wasn't found, do nothing
    if not foundTab then return end
    
    -- Deactivate current active tab
    if self.ActiveTab then
        self.ActiveTab:SetActive(false)
    end
    
    -- Activate the new tab
    self.ActiveTab = foundTab
    foundTab:SetActive(true)
    
    -- Re-render the tabs
    self:RenderTabs()
    
    return foundTab
end

function Window:AddChild(child)
    -- If we have tabs, add the child to the active tab
    if #self.Tabs > 0 and self.ActiveTab then
        return self.ActiveTab:AddChild(child)
    end
    
    -- Otherwise, add to window directly (legacy behavior)
    table.insert(self.Children, child)
    return child
end

function Window:AddLabel(text, position, size, color)
    local yOffset = self.ContentY
    
    local label = Label.new(text, {
        self.Position[1] + (position and position[1] or 10), 
        self.Position[2] + yOffset + (position and position[2] or 0)
    }, size, color)
    
    return self:AddChild(label)
end

function Window:AddButton(text, position, size, callback)
    local yOffset = self.ContentY
    
    local button = Button.new(text, {
        self.Position[1] + (position and position[1] or 10), 
        self.Position[2] + yOffset + (position and position[2] or 0)
    }, size, callback)
    
    return self:AddChild(button)
end

function Window:AddCheckbox(label, position, defaultState, onToggle)
    local yOffset = self.ContentY
    
    local checkbox = Checkbox.new(label, {
        self.Position[1] + (position and position[1] or 10), 
        self.Position[2] + yOffset + (position and position[2] or 0)
    }, defaultState, onToggle)
    
    return self:AddChild(checkbox)
end

function Window:AddSlider(label, position, size, min, max, default, step, onChange)
    local yOffset = self.ContentY
    
    local slider = Slider.new(label, {
        self.Position[1] + (position and position[1] or 10), 
        self.Position[2] + yOffset + (position and position[2] or 0)
    }, size, min, max, default, step, onChange)
    
    return self:AddChild(slider)
end

function Window:SetPosition(position)
    local deltaX = position[1] - self.Position[1]
    local deltaY = position[2] - self.Position[2]
    
    self.Position = position
    
    -- Update window elements
    self.Background.Position = position
    self.Header.Position = position
    self.HeaderAccent.Position = {position[1], position[2] + self.HeaderHeight}
    self.TitleText.Position = {position[1] + 8, position[2] + (self.HeaderHeight/2) - 7}
    self.TabArea.Position = {position[1], position[2] + self.HeaderHeight + 1}
    
    -- Update tab buttons
    self:RenderTabs()
    
    -- Update direct children positions
    for _, child in ipairs(self.Children) do
        if child.Position then
            child:SetPosition({
                child.Position[1] + deltaX,
                child.Position[2] + deltaY
            })
        end
    end
    
    -- Update tab children positions
    for _, tab in ipairs(self.Tabs) do
        for _, child in ipairs(tab.Children) do
            if child.Position then
                child:SetPosition({
                    child.Position[1] + deltaX,
                    child.Position[2] + deltaY
                })
            end
        end
    end
end

function Window:SetVisible(state)
    Object.SetVisible(self, state)
    
    -- Update tab visibility
    for _, tab in ipairs(self.Tabs) do
        tab:SetVisible(state)
    end
    
    -- Update direct children visibility
    for _, child in ipairs(self.Children) do
        child:SetVisible(state)
    end
end

function Window:Destroy()
    Object.Destroy(self)
    
    -- Destroy all tabs
    for _, tab in ipairs(self.Tabs) do
        tab:Destroy()
    end
    self.Tabs = {}
    
    -- Destroy direct children
    for _, child in ipairs(self.Children) do
        child:Destroy()
    end
    self.Children = {}
    self = nil
end

-- Initialize the UIManager
UIManager:Initialize()

-- Library Main Interface
local Anue = {
    Theme = Theme,
    DrawService = DrawService,
    UIManager = UIManager,
    Object = Object,
    Label = Label,
    Button = Button,
    Checkbox = Checkbox,
    Slider = Slider,
    Tab = Tab,
    Window = Window,
    Windows = {}
}

function Anue:CreateWindow(title, position, size)
    local window = Window.new(title, position, size)
    UIManager:RegisterWindow(window)
    table.insert(self.Windows, window)
    return window
end

function Anue:CreateLabel(text, position, size, color)
    local label = Label.new(text, position, size, color)
    UIManager:RegisterElement(label)
    return label
end

function Anue:CreateButton(text, position, size, callback)
    local button = Button.new(text, position, size, callback)
    UIManager:RegisterElement(button)
    return button
end

function Anue:CreateCheckbox(label, position, defaultState, onToggle)
    local checkbox = Checkbox.new(label, position, defaultState, onToggle)
    UIManager:RegisterElement(checkbox)
    return checkbox
end

function Anue:CreateSlider(label, position, size, min, max, default, step, onChange)
    local slider = Slider.new(label, position, size, min, max, default, step, onChange)
    UIManager:RegisterElement(slider)
    return slider
end

function Anue:Destroy()
    UIManager:Destroy()
    
    for _, window in ipairs(self.Windows) do
        window:Destroy()
    end
    
    self.Windows = {}
    Drawing.clear()
end

return Anue
